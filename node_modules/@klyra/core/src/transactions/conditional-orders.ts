import type {
  ChainClient,
  SubaccountInfo,
  WalletSubaccountInfo,
  TxResponsePromise,
} from "@klyra/chain";
import type {
  StopLimitTradeInputs,
  StopMarketTradeInputs,
  TakeProfitLimitTradeInputs,
  TakeProfitMarketTradeInputs,
  TradeFormInputsUnion,
} from "@klyra/cortex";
import {
  OrderExecution,
  type OrderSide,
  OrderTimeInForce,
  OrderType,
} from "@klyra/shared";
import { getRandomClientId } from "./utils";

export async function internalPlaceTakeProfitLimitOrderWithCortex(
  chainClient: ChainClient,
  tradeInputs: TradeFormInputsUnion,
  subaccount: WalletSubaccountInfo,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo
): TxResponsePromise {
  const inputs = tradeInputs as TakeProfitLimitTradeInputs;
  return chainClient.placeOrder(
    subaccount,
    inputs.marketId,
    OrderType.TAKE_PROFIT_LIMIT,
    inputs.side,
    inputs.price,
    inputs.quoteSize,
    getRandomClientId(),
    inputs.timeInForce ?? OrderTimeInForce.GTT,
    inputs.goodTilTime,
    routerFeePpm,
    routerSubaccount,
    inputs.execution ?? OrderExecution.DEFAULT,
    false,
    inputs.reduceOnly,
    inputs.triggerPrice,
    undefined,
    undefined,
    undefined,
    undefined
  );
}

export async function internalPlaceTakeProfitLimitOrder(
  chainClient: ChainClient,
  subaccount: WalletSubaccountInfo,
  ticker: string,
  side: OrderSide,
  price: number,
  triggerPrice: number,
  size: number,
  goodTilBlockTime: number,
  reduceOnly: boolean,
  clientId?: number,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo,
  memo?: string
): TxResponsePromise {
  return await chainClient.placeOrder(
    subaccount,
    ticker,
    OrderType.TAKE_PROFIT_LIMIT,
    side,
    price,
    size,
    clientId ?? getRandomClientId(),
    OrderTimeInForce.GTT,
    goodTilBlockTime,
    routerFeePpm,
    routerSubaccount,
    OrderExecution.DEFAULT,
    false,
    reduceOnly,
    triggerPrice,
    undefined,
    undefined,
    undefined,
    memo
  );
}

export async function internalPlaceTakeProfitMarketOrderWithCortex(
  chainClient: ChainClient,
  tradeInputs: TradeFormInputsUnion,
  subaccount: WalletSubaccountInfo,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo
): TxResponsePromise {
  const inputs = tradeInputs as TakeProfitMarketTradeInputs;
  return chainClient.placeOrder(
    subaccount,
    inputs.marketId,
    OrderType.TAKE_PROFIT_MARKET,
    inputs.side,
    0,
    inputs.quoteSize,
    getRandomClientId(),
    inputs.timeInForce ?? OrderTimeInForce.GTT,
    inputs.goodTilTime,
    routerFeePpm,
    routerSubaccount,
    inputs.execution ?? OrderExecution.IOC,
    false,
    inputs.reduceOnly,
    inputs.triggerPrice,
    undefined,
    undefined,
    undefined,
    undefined
  );
}

export async function internalPlaceTakeProfitMarketOrder(
  chainClient: ChainClient,
  subaccount: WalletSubaccountInfo,
  ticker: string,
  side: OrderSide,
  price: number,
  triggerPrice: number,
  size: number,
  goodTilBlockTime: number,
  reduceOnly: boolean,
  clientId?: number,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo,
  memo?: string
): TxResponsePromise {
  return await chainClient.placeOrder(
    subaccount,
    ticker,
    OrderType.TAKE_PROFIT_MARKET,
    side,
    price,
    size,
    clientId ?? getRandomClientId(),
    OrderTimeInForce.GTT,
    goodTilBlockTime,
    routerFeePpm,
    routerSubaccount,
    OrderExecution.IOC,
    false,
    reduceOnly,
    triggerPrice,
    undefined,
    undefined,
    undefined,
    memo
  );
}

export async function internalPlaceStopLossLimitOrderWithCortex(
  chainClient: ChainClient,
  tradeInputs: TradeFormInputsUnion,
  subaccount: WalletSubaccountInfo,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo
): TxResponsePromise {
  const inputs = tradeInputs as StopLimitTradeInputs;
  return chainClient.placeOrder(
    subaccount,
    inputs.marketId,
    OrderType.STOP_LIMIT,
    inputs.side,
    inputs.price,
    inputs.quoteSize,
    getRandomClientId(),
    inputs.timeInForce ?? OrderTimeInForce.GTT,
    inputs.goodTilTime,
    routerFeePpm,
    routerSubaccount,
    inputs.execution ?? OrderExecution.DEFAULT,
    false,
    inputs.reduceOnly,
    inputs.triggerPrice,
    undefined,
    undefined,
    undefined,
    undefined
  );
}

export async function internalPlaceStopLossLimitOrder(
  chainClient: ChainClient,
  subaccount: WalletSubaccountInfo,
  ticker: string,
  side: OrderSide,
  price: number,
  triggerPrice: number,
  size: number,
  goodTilBlockTime: number,
  reduceOnly: boolean,
  clientId?: number,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo,
  memo?: string
): TxResponsePromise {
  return await chainClient.placeOrder(
    subaccount,
    ticker,
    OrderType.STOP_LIMIT,
    side,
    price,
    size,
    clientId ?? getRandomClientId(),
    OrderTimeInForce.GTT,
    goodTilBlockTime,
    routerFeePpm,
    routerSubaccount,
    OrderExecution.DEFAULT,
    false,
    reduceOnly,
    triggerPrice,
    undefined,
    undefined,
    undefined,
    memo
  );
}

export async function internalPlaceStopLossMarketOrderWithCortex(
  chainClient: ChainClient,
  tradeInputs: TradeFormInputsUnion,
  subaccount: WalletSubaccountInfo,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo
): TxResponsePromise {
  const inputs = tradeInputs as StopMarketTradeInputs;
  return chainClient.placeOrder(
    subaccount,
    inputs.marketId,
    OrderType.STOP_MARKET,
    inputs.side,
    0,
    inputs.quoteSize,
    getRandomClientId(),
    inputs.timeInForce ?? OrderTimeInForce.GTT,
    inputs.goodTilTime,
    routerFeePpm,
    routerSubaccount,
    inputs.execution ?? OrderExecution.IOC,
    false,
    inputs.reduceOnly,
    inputs.triggerPrice,
    undefined,
    undefined,
    undefined,
    undefined
  );
}

export async function internalPlaceStopLossMarketOrder(
  chainClient: ChainClient,
  subaccount: WalletSubaccountInfo,
  ticker: string,
  side: OrderSide,
  price: number,
  triggerPrice: number,
  size: number,
  goodTilBlockTime: number,
  reduceOnly: boolean,
  clientId?: number,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo,
  memo?: string
): TxResponsePromise {
  return await chainClient.placeOrder(
    subaccount,
    ticker,
    OrderType.STOP_MARKET,
    side,
    price,
    size,
    clientId ?? getRandomClientId(),
    OrderTimeInForce.GTT,
    goodTilBlockTime,
    routerFeePpm,
    routerSubaccount,
    OrderExecution.IOC,
    false,
    reduceOnly,
    triggerPrice,
    undefined,
    undefined,
    undefined,
    memo
  );
}
