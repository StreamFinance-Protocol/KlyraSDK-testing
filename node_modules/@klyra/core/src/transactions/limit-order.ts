import {
  type ChainClient,
  type SubaccountInfo,
  type WalletSubaccountInfo,
  type TxResponsePromise,
} from "@klyra/chain";
import {
  type LimitTradeFormInputs,
  type TradeFormInputsUnion,
} from "@klyra/cortex";
import {
  OrderExecution,
  type OrderSide,
  OrderTimeInForce,
  OrderType,
} from "@klyra/shared";
import { getRandomClientId } from "./utils";
import { validateFields } from "./field-validations";

export async function internalPlaceLimitOrderWithCortex(
  chainClient: ChainClient,
  tradeInputs: TradeFormInputsUnion,
  subaccount: WalletSubaccountInfo,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo
): TxResponsePromise {
  const inputs = tradeInputs as LimitTradeFormInputs;
  return chainClient.placeOrder(
    subaccount,
    inputs.marketId,
    OrderType.LIMIT,
    inputs.side,
    inputs.price,
    inputs.quoteSize,
    getRandomClientId(),
    inputs.timeInForce ?? OrderTimeInForce.GTT,
    inputs.goodTilTime,
    routerFeePpm,
    routerSubaccount,
    inputs.execution ?? OrderExecution.DEFAULT,
    false,
    inputs.reduceOnly,
    undefined,
    undefined,
    undefined,
    undefined,
    undefined
  );
}

export async function internalPlaceLimitOrder(
  chainClient: ChainClient,
  subaccount: WalletSubaccountInfo,
  ticker: string,
  side: OrderSide,
  price: number,
  size: number,
  goodTilBlockTime: number,
  reduceOnly: boolean,
  clientId?: number,
  routerFeePpm?: number,
  routerSubaccount?: SubaccountInfo,
  memo?: string
): TxResponsePromise {
  return await chainClient.placeOrder(
    subaccount,
    ticker,
    OrderType.LIMIT,
    side,
    price,
    size,
    clientId ?? getRandomClientId(),
    OrderTimeInForce.GTT,
    goodTilBlockTime,
    routerFeePpm,
    routerSubaccount,
    OrderExecution.DEFAULT,
    false,
    reduceOnly,
    undefined,
    undefined,
    undefined,
    undefined,
    memo
  );
}

export function hasReceivedNecessaryLimitOrderArgs(
  isUsingCortexForms: boolean,
  subaccount?: WalletSubaccountInfo,
  ticker?: string,
  side?: OrderSide,
  price?: number,
  size?: number,
  goodTilBlockTime?: number,
  reduceOnly?: boolean
): boolean {
  return validateFields({
    subaccount,
    ticker,
    side,
    price,
    size,
    goodTilTime: goodTilBlockTime,
    reduceOnly,
  });
}
