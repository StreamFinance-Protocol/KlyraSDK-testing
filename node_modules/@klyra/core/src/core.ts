import {
  ChainClient,
  type LocalWallet,
  type MarketInfo,
  OrderFlags,
  SubaccountInfo,
  type TxResponsePromise,
  WalletSubaccountInfo,
  getAccountFromSignedMessage as _getAccountFromSignedMessage,
  getAccountFromUUID as _getAccountFromUUID,
} from "@klyra/chain";
import StateManager, {
  FormType,
  type LimitTradeFormInputs,
  type MarketTradeFormInputs,
  type StateChangeListener,
  type StateManagerConfig,
  type StopLimitTradeInputs,
  type StopMarketTradeInputs,
  type StoreState,
  type TakeProfitLimitTradeInputs,
  type TakeProfitMarketTradeInputs,
  type TradeFormInputsUnion,
} from "@klyra/cortex";
import { Config, type Environment } from "@klyra/shared";
import {
  type IndexerSubaccountOrder,
  MessageChannel,
  MessageType,
  type OrderExecution,
  type OrderSide,
  type OrderTimeInForce,
  type OrderType,
  type WebSocketConfig,
  type WebSocketMessage,
  type WebSocketSubscriptionMessage,
  type IndexerSubaccountAssetPosition,
  type IndexerSubaccountFill,
  type IndexerSubaccountTransfer,
  type IndexerSubaccountHistoricalPnl,
  type IndexerSubaccountResponse,
  type IndexerPerpetualMarket,
  type IndexerCandleContents,
  type IndexerOrderbook,
  type IndexerHistoricalFunding,
  type IndexerTrade,
} from "@klyra/shared";
import WebSocketManager from "@klyra/ws";
import { validateFields } from "./transactions/field-validations";
import { hasReceivedNecessaryCancelOrderArgs } from "./transactions/cancel-order";
import {
  internalPlaceStopLossLimitOrder,
  internalPlaceStopLossLimitOrderWithCortex,
  internalPlaceStopLossMarketOrder,
  internalPlaceStopLossMarketOrderWithCortex,
  internalPlaceTakeProfitLimitOrder,
  internalPlaceTakeProfitLimitOrderWithCortex,
  internalPlaceTakeProfitMarketOrder,
  internalPlaceTakeProfitMarketOrderWithCortex,
} from "./transactions/conditional-orders";
import {
  internalPlaceLimitOrder,
  internalPlaceLimitOrderWithCortex,
} from "./transactions/limit-order";
import {
  internalPlaceMarketOrder,
  internalPlaceMarketOrderWithCortex,
} from "./transactions/market-order";
import { hasValidTransferArgs } from "./transactions/transfers";

type WebSocketOptions = Omit<WebSocketConfig, "url"> & {
  enabled?: boolean;
  subscribeOnConnect?: boolean;
};

interface KlyraOptions {
  environment: Environment;
  fees: {
    feePpm: number;
    address: string;
    subaccountNumber: number;
  };
  websocket?: WebSocketOptions;
  cortex?: StateManagerConfig;
}

export class Klyra {
  private stateManager: StateManager;
  private readonly websocketManager: WebSocketManager;
  private readonly config: Config;
  private readonly chainClient: ChainClient;
  private subscribeOnConnect: boolean;
  private websocketEnabled: boolean;
  private routerSubaccountInfo: SubaccountInfo;
  private routerFeePpm: number;

  constructor(config: KlyraOptions) {
    this.config = new Config(config.environment);
    const envConfig = this.config.getEnvConfig();

    this.routerSubaccountInfo = new SubaccountInfo(
      config.fees.address,
      config.fees.subaccountNumber
    );
    this.routerFeePpm = config.fees.feePpm;

    // TODO: make this customizable by the user (they can pass their own statemanager)
    this.stateManager = new StateManager({ ...config.cortex });
    this.websocketManager = new WebSocketManager({
      ...config.websocket,
      url: envConfig.indexer.ws,
    });

    this.chainClient = new ChainClient({
      node: {
        restUrl: envConfig.node.rest,
        chainId: envConfig.chainId,
      },
      indexer: {
        urls: envConfig.indexer,
      },
    });
    this.subscribeOnConnect = config.websocket?.subscribeOnConnect ?? true;
    this.websocketEnabled = config.websocket?.enabled ?? true;
  }

  async initialize(): Promise<void> {
    this.websocketManager.on("message", (message: unknown) => {
      this.webSocketMessageReceived(message as WebSocketMessage<unknown>);
    });
    this.websocketManager.connect();
    await this.chainClient.initialize();
  }

  close(): void {
    this.websocketManager.disconnect();
  }

  getStore(): StoreState {
    return this.stateManager.getState();
  }

  subscribeToState(listener: StateChangeListener): StateChangeListener {
    return this.stateManager.subscribeToState(listener);
  }

  webSocketMessageReceived(message: WebSocketMessage<unknown>): void {
    // if the message type is connected, we need to subscribe to all channels
    if (message.type === MessageType.CONNECTED) {
      const channelsToSubscribe: [MessageChannel, string?][] = [
        [MessageChannel.MARKETS],
        // We don't connect to account because at this point the user hasn't authenticated yet
        // On authenticated, we will connect to account channel
      ];

      const { currentMarketTicker, user } = this.stateManager.getState();
      // If the app has a default market id, we subscribe to the specific market channels
      // Otherwise, we subscribe only to the general channels (markets) and wait for a user to set a market id
      if (currentMarketTicker) {
        channelsToSubscribe.push([MessageChannel.CANDLES, currentMarketTicker]);
        channelsToSubscribe.push([
          MessageChannel.ORDERBOOK,
          currentMarketTicker,
        ]);
        channelsToSubscribe.push([MessageChannel.TRADES, currentMarketTicker]);
      }

      if (user.address) {
        channelsToSubscribe.push([
          MessageChannel.PARENT_SUBACCOUNTS,
          `${user.address}/0`,
        ]);
      }

      if (this.subscribeOnConnect) {
        channelsToSubscribe.forEach(([channel, id]) => {
          this.subscribeToWebSocketChannel(channel, id);
        });
      }

      return;
    }

    // otherwise, it's a "subscribed" or "channel_batch_data" message
    // so we pass it to Cortex
    this.stateManager.handleMessage(message);
  }

  subscribeToWebSocketChannel(channel: MessageChannel, id?: string): void {
    if (this.websocketEnabled && this.websocketManager.isConnected) {
      this.websocketManager.send({
        type: MessageType.SUBSCRIBE,
        channel,
        batched: true,
        id,
      } as WebSocketSubscriptionMessage);
    }
  }

  getChainClient(): ChainClient {
    return this.chainClient;
  }

  setCurrentTicker(ticker: string): void {
    this.stateManager.setCurrentMarketTicker(ticker);

    // subscribe to the specific market channels
    this.subscribeToWebSocketChannel(MessageChannel.CANDLES, ticker);
    this.subscribeToWebSocketChannel(MessageChannel.ORDERBOOK, ticker);
    this.subscribeToWebSocketChannel(MessageChannel.TRADES, ticker);
  }

  formInput(formType: FormType, fieldName: string, value: unknown): void {
    this.stateManager.formInput(formType, fieldName, value);
  }

  setSubaccountNumber(subaccountNumber: number): void {
    this.stateManager.setSubaccountNumber(subaccountNumber);
  }

  async getSubaccountFromSignature(
    signature: string,
    subaccountNumber = 0
  ): Promise<{
    subaccount: WalletSubaccountInfo;
    wallet: LocalWallet;
    address: string;
  }> {
    const { wallet, address } =
      await this.authenticateUserFromSignature(signature);
    const subaccountInfo = new WalletSubaccountInfo(wallet, subaccountNumber);
    return { subaccount: subaccountInfo, wallet, address };
  }

  async getSubaccountFromUUID(
    uuid: string,
    subaccountNumber = 0
  ): Promise<{
    subaccount: WalletSubaccountInfo;
    wallet: LocalWallet;
    address: string;
  }> {
    const { wallet, address } = await this.authenticateUserFromUUID(uuid);
    const subaccountInfo = new WalletSubaccountInfo(wallet, subaccountNumber);
    return { subaccount: subaccountInfo, wallet, address };
  }
  private async authenticateUserFromUUID(uuid: string): Promise<{
    wallet: LocalWallet;
    address: string;
  }> {
    const { wallet } = await _getAccountFromUUID(uuid);
    const address = wallet.getAddress();

    this.subscribeToWebSocketChannel(
      MessageChannel.PARENT_SUBACCOUNTS,
      `${address}/0` // we add the subaccount number to the end to subscribe to the parent subaccount
    );

    this.stateManager.setAddress(address);
    this.setSubaccountNumber(0);
    this.stateManager.setWalletInfo(wallet);

    return { wallet, address };
  }

  private async authenticateUserFromSignature(signedMessage: string): Promise<{
    wallet: LocalWallet;
    address: string;
  }> {
    const { wallet } = await _getAccountFromSignedMessage(signedMessage);
    const address = wallet.getAddress();

    this.subscribeToWebSocketChannel(
      MessageChannel.PARENT_SUBACCOUNTS,
      `${address}/0` // we add the subaccount number to the end to subscribe to the parent subaccount
    );

    this.stateManager.setAddress(address);
    this.setSubaccountNumber(0);
    this.stateManager.setWalletInfo(wallet);

    return { wallet, address };
  }

  getOrderbookPrice(ticker: string): number {
    const state = this.stateManager.getState();
    return state.orderbooks[ticker]?.midPrice ?? 0;
  }

  async getCurrentBlock(): Promise<number> {
    const { height } = await this.chainClient.indexerClient.utils.getHeight();
    return parseInt(height);
  }

  async getCurrentBlockTime(): Promise<number> {
    const time = await this.chainClient.indexerClient.utils.getTime();
    return new Date(time.iso).getTime();
  }

  private getTradeInputs(): TradeFormInputsUnion {
    const state = this.stateManager.getState();
    const tradeForm = state.forms[FormType.TRADE];

    return tradeForm.inputs;
  }

  async placeMarketOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    side?: OrderSide,
    size?: number,
    reduceOnly?: boolean,
    clientId?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    if (this.config.isUsingCortexForms()) {
      const inputs = this.getTradeInputs() as MarketTradeFormInputs;

      const hasValidInputs = validateFields({
        ticker: inputs.marketId,
        side: inputs.side,
        size: inputs.quoteSize,
        reduceOnly: inputs.reduceOnly,
      });

      if (!hasValidInputs) {
        throw new Error("Invalid market order inputs");
      }

      return internalPlaceMarketOrderWithCortex(
        this.chainClient,
        inputs,
        subaccountInfo,
        this.getOrderbookPrice(inputs.marketId),
        await this.getCurrentBlock(),
        routerFeePpm ?? this.routerFeePpm,
        routerSubaccount ?? this.routerSubaccountInfo
      );
    }
    const hasValidInputs = validateFields({
      subaccount,
      ticker,
      side,
      size,
      reduceOnly,
    });

    if (!hasValidInputs) {
      throw new Error(
        "When Cortex is disabled, you must pass in order arguments"
      );
    }

    return internalPlaceMarketOrder(
      this.chainClient,
      subaccountInfo,
      ticker!,
      side!,
      this.getOrderbookPrice(ticker!),
      size!,
      reduceOnly!,
      await this.getCurrentBlock(),
      clientId,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      memo
    );
  }

  async placeLimitOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    side?: OrderSide,
    price?: number,
    size?: number,
    goodTilBlockTime?: number,
    reduceOnly?: boolean,
    clientId?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    if (this.config.isUsingCortexForms()) {
      const inputs = this.getTradeInputs() as LimitTradeFormInputs;

      const hasValidInputs = validateFields({
        ticker: inputs.marketId,
        side: inputs.side,
        price: inputs.price,
        size: inputs.quoteSize,
        goodTilTime: inputs.goodTilTime,
        reduceOnly: inputs.reduceOnly,
      });

      if (!hasValidInputs) {
        throw new Error("Invalid limit order inputs");
      }

      return internalPlaceLimitOrderWithCortex(
        this.chainClient,
        inputs,
        subaccountInfo,
        routerFeePpm ?? this.routerFeePpm,
        routerSubaccount ?? this.routerSubaccountInfo
      );
    }
    const hasValidInputs = validateFields({
      subaccount,
      ticker,
      side,
      price,
      size,
      goodTilTime: goodTilBlockTime,
      reduceOnly,
    });

    if (!hasValidInputs) {
      throw new Error(
        "When Cortex is disabled, you must pass in order arguments"
      );
    }

    return await internalPlaceLimitOrder(
      this.chainClient,
      subaccountInfo,
      ticker!,
      side!,
      price!,
      size!,
      goodTilBlockTime!,
      reduceOnly!,
      clientId,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      memo
    );
  }

  async placeStopLossLimitOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    side?: OrderSide,
    price?: number,
    triggerPrice?: number,
    size?: number,
    goodTilBlockTime?: number,
    reduceOnly?: boolean,
    clientId?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    if (this.config.isUsingCortexForms()) {
      const inputs = this.getTradeInputs() as StopLimitTradeInputs;

      const hasValidInputs = validateFields({
        ticker: inputs.marketId,
        side: inputs.side,
        price: inputs.price,
        triggerPrice: inputs.triggerPrice,
        size: inputs.quoteSize,
        goodTilTime: inputs.goodTilTime,
        reduceOnly: inputs.reduceOnly,
      });

      if (!hasValidInputs) {
        throw new Error("Invalid stop loss limit order inputs");
      }

      return internalPlaceStopLossLimitOrderWithCortex(
        this.chainClient,
        inputs,
        subaccountInfo,
        routerFeePpm ?? this.routerFeePpm,
        routerSubaccount ?? this.routerSubaccountInfo
      );
    }
    const hasValidInputs = validateFields({
      subaccount,
      ticker,
      side,
      price,
      triggerPrice,
      size,
      goodTilTime: goodTilBlockTime,
      reduceOnly,
    });

    if (!hasValidInputs) {
      throw new Error(
        "When Cortex is disabled, you must pass in order arguments"
      );
    }

    return await internalPlaceStopLossLimitOrder(
      this.chainClient,
      subaccountInfo,
      ticker!,
      side!,
      price!,
      triggerPrice!,
      size!,
      goodTilBlockTime!,
      reduceOnly!,
      clientId,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      memo
    );
  }

  async placeStopLossMarketOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    side?: OrderSide,
    triggerPrice?: number,
    size?: number,
    goodTilBlockTime?: number,
    reduceOnly?: boolean,
    clientId?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    if (this.config.isUsingCortexForms()) {
      const inputs = this.getTradeInputs() as StopMarketTradeInputs;

      const hasValidInputs = validateFields({
        ticker: inputs.marketId,
        side: inputs.side,
        triggerPrice: inputs.triggerPrice,
        size: inputs.quoteSize,
        goodTilTime: inputs.goodTilTime,
        reduceOnly: inputs.reduceOnly,
      });

      if (!hasValidInputs) {
        throw new Error("Invalid stop loss market order inputs");
      }

      return internalPlaceStopLossMarketOrderWithCortex(
        this.chainClient,
        inputs,
        subaccountInfo,
        routerFeePpm ?? this.routerFeePpm,
        routerSubaccount ?? this.routerSubaccountInfo
      );
    }
    const hasValidInputs = validateFields({
      subaccount,
      ticker,
      side,
      triggerPrice,
      size,
      goodTilTime: goodTilBlockTime,
      reduceOnly,
    });

    if (!hasValidInputs) {
      throw new Error(
        "When Cortex is disabled, you must pass in order arguments"
      );
    }

    return await internalPlaceStopLossMarketOrder(
      this.chainClient,
      subaccountInfo,
      ticker!,
      side!,
      0,
      triggerPrice!,
      size!,
      goodTilBlockTime!,
      reduceOnly!,
      clientId,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      memo
    );
  }

  async placeTakeProfitMarketOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    side?: OrderSide,
    triggerPrice?: number,
    size?: number,
    goodTilBlockTime?: number,
    reduceOnly?: boolean,
    clientId?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    if (this.config.isUsingCortexForms()) {
      const inputs = this.getTradeInputs() as TakeProfitMarketTradeInputs;
      const hasValidInputs = validateFields({
        ticker: inputs.marketId,
        side: inputs.side,
        triggerPrice: inputs.triggerPrice,
        size: inputs.quoteSize,
        goodTilTime: inputs.goodTilTime,
        reduceOnly: inputs.reduceOnly,
      });

      if (!hasValidInputs) {
        throw new Error("Invalid take profit market order inputs");
      }

      return internalPlaceTakeProfitMarketOrderWithCortex(
        this.chainClient,
        inputs,
        subaccountInfo,
        routerFeePpm ?? this.routerFeePpm,
        routerSubaccount ?? this.routerSubaccountInfo
      );
    }
    const hasValidInputs = validateFields({
      subaccount,
      ticker,
      side,
      triggerPrice,
      size,
      goodTilTime: goodTilBlockTime,
      reduceOnly,
    });

    if (!hasValidInputs) {
      throw new Error(
        "When Cortex is disabled, you must pass in order arguments"
      );
    }

    return await internalPlaceTakeProfitMarketOrder(
      this.chainClient,
      subaccountInfo,
      ticker!,
      side!,
      0,
      triggerPrice!,
      size!,
      goodTilBlockTime!,
      reduceOnly!,
      clientId,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      memo
    );
  }

  async placeTakeProfitLimitOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    side?: OrderSide,
    price?: number,
    triggerPrice?: number,
    size?: number,
    goodTilBlockTime?: number,
    reduceOnly?: boolean,
    clientId?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    if (this.config.isUsingCortexForms()) {
      const inputs = this.getTradeInputs() as TakeProfitLimitTradeInputs;
      const hasValidInputs = validateFields({
        ticker: inputs.marketId,
        side: inputs.side,
        price: inputs.price,
        triggerPrice: inputs.triggerPrice,
        size: inputs.quoteSize,
        goodTilTime: inputs.goodTilTime,
        reduceOnly: inputs.reduceOnly,
      });

      if (!hasValidInputs) {
        throw new Error("Invalid take profit limit order inputs");
      }

      const subaccountInfo = this.getSubaccountInfo(subaccount);

      return internalPlaceTakeProfitLimitOrderWithCortex(
        this.chainClient,
        inputs,
        subaccountInfo,
        routerFeePpm ?? this.routerFeePpm,
        routerSubaccount ?? this.routerSubaccountInfo
      );
    }
    const hasValidInputs = validateFields({
      subaccount,
      ticker,
      side,
      price,
      triggerPrice,
      size,
      goodTilTime: goodTilBlockTime,
      reduceOnly,
    });

    if (!hasValidInputs) {
      throw new Error(
        "When Cortex is disabled, you must pass in order arguments"
      );
    }

    return await internalPlaceTakeProfitLimitOrder(
      this.chainClient,
      subaccount!,
      ticker!,
      side!,
      price!,
      triggerPrice!,
      size!,
      goodTilBlockTime!,
      reduceOnly!,
      clientId,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      memo
    );
  }

  async placeCustomOrder(
    subaccount: WalletSubaccountInfo,
    ticker: string,
    type: OrderType,
    side: OrderSide,
    price: number,
    size: number,
    clientId: number,
    timeInForce?: OrderTimeInForce,
    goodTilTimeInSeconds?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    execution?: OrderExecution,
    postOnly?: boolean,
    reduceOnly?: boolean,
    triggerPrice?: number,
    marketInfo?: MarketInfo,
    currentHeight?: number,
    goodTilBlock?: number,
    memo?: string
  ): TxResponsePromise {
    return await this.chainClient.placeOrder(
      subaccount,
      ticker,
      type,
      side,
      price,
      size,
      clientId,
      timeInForce,
      goodTilTimeInSeconds,
      routerFeePpm ?? this.routerFeePpm,
      routerSubaccount ?? this.routerSubaccountInfo,
      execution,
      postOnly,
      reduceOnly,
      triggerPrice,
      marketInfo,
      currentHeight,
      goodTilBlock,
      memo
    );
  }

  async cancelMarketOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    clientId?: number,
    goodTilBlock?: number
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    const hasValidInputs = hasReceivedNecessaryCancelOrderArgs(
      false,
      null,
      subaccountInfo,
      ticker,
      clientId,
      goodTilBlock
    );

    if (!hasValidInputs) {
      throw new Error("You must pass in order arguments to cancel an order.");
    }

    return await this.chainClient.cancelOrder(
      subaccountInfo,
      clientId!,
      OrderFlags.SHORT_TERM,
      ticker!,
      goodTilBlock
    );
  }

  async cancelLimitOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    clientId?: number,
    goodTilBlockTime?: number
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }
    // const currBlock = await this.getCurrentBlock();

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    const hasValidInputs = hasReceivedNecessaryCancelOrderArgs(
      true,
      null,
      subaccountInfo,
      ticker,
      clientId
    );

    if (!hasValidInputs) {
      throw new Error("You must pass in order arguments to cancel an order.");
    }

    return await this.chainClient.cancelOrder(
      subaccountInfo,
      clientId!,
      OrderFlags.LONG_TERM,
      ticker!,
      undefined,
      goodTilBlockTime
    );
  }

  async cancelConditionalOrder(
    subaccount?: WalletSubaccountInfo,
    ticker?: string,
    clientId?: number,
    goodTilBlockTime?: number
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const subaccountInfo = this.getSubaccountInfo(subaccount);

    const hasValidInputs = hasReceivedNecessaryCancelOrderArgs(
      true,
      null,
      subaccountInfo,
      ticker,
      clientId
    );

    if (!hasValidInputs) {
      throw new Error("You must pass in order arguments to cancel an order.");
    }

    return await this.chainClient.cancelOrder(
      subaccountInfo,
      clientId!,
      OrderFlags.CONDITIONAL,
      ticker!,
      undefined,
      goodTilBlockTime
    );
  }

  async transfer(
    subaccount: WalletSubaccountInfo,
    recipientAddress: string,
    recipientSubaccountNumber: number,
    amount: string
  ): TxResponsePromise {
    if (!this.chainClient.isInitialized) {
      throw new Error("Chain client not initialized");
    }

    const hasValidInputs = hasValidTransferArgs(
      subaccount,
      recipientAddress,
      recipientSubaccountNumber,
      amount
    );

    if (!hasValidInputs) {
      throw new Error("You must pass in order arguments to transfer an asset.");
    }

    return this.chainClient.transferToSubaccount(
      subaccount,
      recipientAddress,
      recipientSubaccountNumber,
      amount
    );
  }

  async getMarketInfo(ticker: string): Promise<IndexerPerpetualMarket> {
    const marketsClient = this.chainClient.indexerClient.markets;
    const marketInfo = await marketsClient.getPerpetualMarket(ticker);
    return marketInfo;
  }

  async getMarketCandles(
    ticker: string,
    resolution: string,
    fromISO?: string,
    toISO?: string
  ): Promise<IndexerCandleContents[]> {
    const marketsClient = this.chainClient.indexerClient.markets;
    const candles = await marketsClient.getPerpetualMarketCandles(
      ticker,
      resolution,
      fromISO,
      toISO
    );
    return candles.candles;
  }

  async getOrderbook(ticker: string): Promise<IndexerOrderbook> {
    const marketsClient = this.chainClient.indexerClient.markets;
    const orderbook = marketsClient.getPerpetualMarketOrderbook(ticker);
    return orderbook;
  }

  async getMarketTrades(
    ticker: string,
    startingBeforeOrAt?: string,
    page?: number
  ): Promise<IndexerTrade[]> {
    const marketsClient = this.chainClient.indexerClient.markets;
    const trades = await marketsClient.getPerpetualMarketTrades(
      ticker,
      undefined,
      startingBeforeOrAt,
      undefined,
      page
    );
    return trades.trades;
  }

  async getHistoricalFundingRates(
    ticker: string
  ): Promise<IndexerHistoricalFunding[]> {
    const marketsClient = this.chainClient.indexerClient.markets;
    const historicalFundings =
      await marketsClient.getPerpetualMarketHistoricalFunding(ticker);
    return historicalFundings.historicalFunding;
  }

  async getUserPositions(
    address: string,
    subaccountNumber: number
  ): Promise<{ positions: IndexerSubaccountAssetPosition[] }> {
    const account = this.chainClient.indexerClient.account;
    const trades = await account.getSubaccountAssetPositions(
      address,
      subaccountNumber
    );
    return trades;
  }

  // TODO(UCC) - we should transition types like IndexerOrderSide to OrderSide in the return
  async getUserOrders(
    address: string,
    subaccountNumber: number,
    ticker?: string,
    side?: OrderSide
  ): Promise<IndexerSubaccountOrder[]> {
    const account = this.chainClient.indexerClient.account;
    const orders = await account.getSubaccountOrders(
      address,
      subaccountNumber,
      ticker,
      side
    );
    return orders;
  }

  async getUserFills(
    address: string,
    subaccountNumber: number,
    ticker?: string,
    createdBeforeOrAt?: string,
    page?: number
  ): Promise<{ fills: IndexerSubaccountFill[] }> {
    const account = this.chainClient.indexerClient.account;
    const fills = await account.getSubaccountFills(
      address,
      subaccountNumber,
      ticker,
      undefined,
      undefined,
      createdBeforeOrAt,
      page
    );
    return fills;
  }

  async getUserTransfers(
    address: string,
    subaccountNumber: number,
    createdBeforeOrAt?: string,
    page?: number
  ): Promise<{ transfers: IndexerSubaccountTransfer[] }> {
    const account = this.chainClient.indexerClient.account;
    const transfers = await account.getSubaccountTransfers(
      address,
      subaccountNumber,
      undefined,
      undefined,
      createdBeforeOrAt,
      page
    );
    return transfers;
  }

  async getUserHistoricalPNLs(
    address: string,
    subaccountNumber: number,
    createdOnOrAfter?: string,
    page?: number
  ): Promise<{ historicalPnls: IndexerSubaccountHistoricalPnl[] }> {
    const account = this.chainClient.indexerClient.account;
    const pnls = await account.getSubaccountHistoricalPNLs(
      address,
      subaccountNumber,
      undefined,
      undefined,
      undefined,
      createdOnOrAfter,
      undefined,
      page
    );
    return pnls;
  }

  async getParentSubaccountFills(
    address: string,
    parentSubaccountNumber: number,
    ticker?: string,
    limit?: number,
    createdBeforeOrAtHeight?: number,
    createdBeforeOrAt?: string,
    page?: number
  ): Promise<{ fills: IndexerSubaccountFill[] }> {
    const account = this.chainClient.indexerClient.account;
    const fills = await account.getParentSubaccountNumberFills(
      address,
      parentSubaccountNumber,
      ticker,
      limit,
      createdBeforeOrAtHeight,
      createdBeforeOrAt,
      page
    );
    return fills;
  }

  async getParentSubaccountTransfers(
    address: string,
    parentSubaccountNumber: number,
    limit?: number,
    createdBeforeOrAtHeight?: number,
    createdBeforeOrAt?: string,
    page?: number
  ): Promise<{ transfers: IndexerSubaccountTransfer[] }> {
    const account = this.chainClient.indexerClient.account;
    const transfers = await account.getParentSubaccountNumberTransfers(
      address,
      parentSubaccountNumber,
      limit,
      createdBeforeOrAtHeight,
      createdBeforeOrAt,
      page
    );
    return transfers;
  }

  async getAllUserSubaccountsInfo(
    address: string
  ): Promise<IndexerSubaccountResponse[]> {
    const account = this.chainClient.indexerClient.account;
    const subaccounts = await account.getSubaccounts(address);
    return subaccounts.subaccounts;
  }

  async getUserSubaccountInfo(
    address: string,
    subaccountNumber: number
  ): Promise<{ subaccount: IndexerSubaccountResponse }> {
    const account = this.chainClient.indexerClient.account;
    const subaccount = await account.getSubaccount(address, subaccountNumber);
    return subaccount;
  }

  async getOrder(orderId: string): Promise<IndexerSubaccountOrder> {
    const account = this.chainClient.indexerClient.account;
    const order = await account.getOrder(orderId);
    return order;
  }

  async getAllMarkets(): Promise<Record<string, IndexerPerpetualMarket>> {
    const marketsClient = this.chainClient.indexerClient.markets;
    const markets = await marketsClient.getAllPerpetualMarkets();
    return markets.markets;
  }

  private getSubaccountInfo(
    subaccount?: WalletSubaccountInfo
  ): WalletSubaccountInfo {
    let subaccountInfo: WalletSubaccountInfo | undefined = subaccount;

    if (!subaccountInfo) {
      const { subaccountNumber, wallet } = this.stateManager.getState().user;
      if (!wallet) {
        throw new Error(
          "You must authenticate the user (via `authenticateUser(...)`) before cancelling an order."
        );
      }
      subaccountInfo = new WalletSubaccountInfo(wallet, subaccountNumber);
    }

    return subaccountInfo;
  }
}
