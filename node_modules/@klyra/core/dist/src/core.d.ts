import { ChainClient, type LocalWallet, type MarketInfo, SubaccountInfo, type TxResponsePromise, WalletSubaccountInfo } from "@klyra/chain";
import { FormType, type StateChangeListener, type StateManagerConfig, type StoreState } from "@klyra/cortex";
import { type Environment } from "@klyra/shared";
import { type IndexerSubaccountOrder, MessageChannel, type OrderExecution, type OrderSide, type OrderTimeInForce, type OrderType, type WebSocketConfig, type WebSocketMessage, type IndexerSubaccountAssetPosition, type IndexerSubaccountFill, type IndexerSubaccountTransfer, type IndexerSubaccountHistoricalPnl, type IndexerSubaccountResponse, type IndexerPerpetualMarket, type IndexerCandleContents, type IndexerOrderbook, type IndexerHistoricalFunding, type IndexerTrade } from "@klyra/shared";
type WebSocketOptions = Omit<WebSocketConfig, "url"> & {
    enabled?: boolean;
    subscribeOnConnect?: boolean;
};
interface KlyraOptions {
    environment: Environment;
    fees: {
        feePpm: number;
        address: string;
        subaccountNumber: number;
    };
    websocket?: WebSocketOptions;
    cortex?: StateManagerConfig;
}
export declare class Klyra {
    private stateManager;
    private readonly websocketManager;
    private readonly config;
    private readonly chainClient;
    private subscribeOnConnect;
    private websocketEnabled;
    private routerSubaccountInfo;
    private routerFeePpm;
    constructor(config: KlyraOptions);
    initialize(): Promise<void>;
    close(): void;
    getStore(): StoreState;
    subscribeToState(listener: StateChangeListener): StateChangeListener;
    webSocketMessageReceived(message: WebSocketMessage<unknown>): void;
    subscribeToWebSocketChannel(channel: MessageChannel, id?: string): void;
    getChainClient(): ChainClient;
    setCurrentTicker(ticker: string): void;
    formInput(formType: FormType, fieldName: string, value: unknown): void;
    setSubaccountNumber(subaccountNumber: number): void;
    getSubaccountFromSignature(signature: string, subaccountNumber?: number): Promise<{
        subaccount: WalletSubaccountInfo;
        wallet: LocalWallet;
        address: string;
    }>;
    getSubaccountFromUUID(uuid: string, subaccountNumber?: number): Promise<{
        subaccount: WalletSubaccountInfo;
        wallet: LocalWallet;
        address: string;
    }>;
    private authenticateUserFromUUID;
    private authenticateUserFromSignature;
    getOrderbookPrice(ticker: string): number;
    getCurrentBlock(): Promise<number>;
    getCurrentBlockTime(): Promise<number>;
    private getTradeInputs;
    placeMarketOrder(subaccount?: WalletSubaccountInfo, ticker?: string, side?: OrderSide, size?: number, reduceOnly?: boolean, clientId?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    placeLimitOrder(subaccount?: WalletSubaccountInfo, ticker?: string, side?: OrderSide, price?: number, size?: number, goodTilBlockTime?: number, reduceOnly?: boolean, clientId?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    placeStopLossLimitOrder(subaccount?: WalletSubaccountInfo, ticker?: string, side?: OrderSide, price?: number, triggerPrice?: number, size?: number, goodTilBlockTime?: number, reduceOnly?: boolean, clientId?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    placeStopLossMarketOrder(subaccount?: WalletSubaccountInfo, ticker?: string, side?: OrderSide, triggerPrice?: number, size?: number, goodTilBlockTime?: number, reduceOnly?: boolean, clientId?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    placeTakeProfitMarketOrder(subaccount?: WalletSubaccountInfo, ticker?: string, side?: OrderSide, triggerPrice?: number, size?: number, goodTilBlockTime?: number, reduceOnly?: boolean, clientId?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    placeTakeProfitLimitOrder(subaccount?: WalletSubaccountInfo, ticker?: string, side?: OrderSide, price?: number, triggerPrice?: number, size?: number, goodTilBlockTime?: number, reduceOnly?: boolean, clientId?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    placeCustomOrder(subaccount: WalletSubaccountInfo, ticker: string, type: OrderType, side: OrderSide, price: number, size: number, clientId: number, timeInForce?: OrderTimeInForce, goodTilTimeInSeconds?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, execution?: OrderExecution, postOnly?: boolean, reduceOnly?: boolean, triggerPrice?: number, marketInfo?: MarketInfo, currentHeight?: number, goodTilBlock?: number, memo?: string): TxResponsePromise;
    cancelMarketOrder(subaccount?: WalletSubaccountInfo, ticker?: string, clientId?: number, goodTilBlock?: number): TxResponsePromise;
    cancelLimitOrder(subaccount?: WalletSubaccountInfo, ticker?: string, clientId?: number, goodTilBlockTime?: number): TxResponsePromise;
    cancelConditionalOrder(subaccount?: WalletSubaccountInfo, ticker?: string, clientId?: number, goodTilBlockTime?: number): TxResponsePromise;
    transfer(subaccount: WalletSubaccountInfo, recipientAddress: string, recipientSubaccountNumber: number, amount: string): TxResponsePromise;
    getMarketInfo(ticker: string): Promise<IndexerPerpetualMarket>;
    getMarketCandles(ticker: string, resolution: string, fromISO?: string, toISO?: string): Promise<IndexerCandleContents[]>;
    getOrderbook(ticker: string): Promise<IndexerOrderbook>;
    getMarketTrades(ticker: string, startingBeforeOrAt?: string, page?: number): Promise<IndexerTrade[]>;
    getHistoricalFundingRates(ticker: string): Promise<IndexerHistoricalFunding[]>;
    getUserPositions(address: string, subaccountNumber: number): Promise<{
        positions: IndexerSubaccountAssetPosition[];
    }>;
    getUserOrders(address: string, subaccountNumber: number, ticker?: string, side?: OrderSide): Promise<IndexerSubaccountOrder[]>;
    getUserFills(address: string, subaccountNumber: number, ticker?: string, createdBeforeOrAt?: string, page?: number): Promise<{
        fills: IndexerSubaccountFill[];
    }>;
    getUserTransfers(address: string, subaccountNumber: number, createdBeforeOrAt?: string, page?: number): Promise<{
        transfers: IndexerSubaccountTransfer[];
    }>;
    getUserHistoricalPNLs(address: string, subaccountNumber: number, createdOnOrAfter?: string, page?: number): Promise<{
        historicalPnls: IndexerSubaccountHistoricalPnl[];
    }>;
    getParentSubaccountFills(address: string, parentSubaccountNumber: number, ticker?: string, limit?: number, createdBeforeOrAtHeight?: number, createdBeforeOrAt?: string, page?: number): Promise<{
        fills: IndexerSubaccountFill[];
    }>;
    getParentSubaccountTransfers(address: string, parentSubaccountNumber: number, limit?: number, createdBeforeOrAtHeight?: number, createdBeforeOrAt?: string, page?: number): Promise<{
        transfers: IndexerSubaccountTransfer[];
    }>;
    getAllUserSubaccountsInfo(address: string): Promise<IndexerSubaccountResponse[]>;
    getUserSubaccountInfo(address: string, subaccountNumber: number): Promise<{
        subaccount: IndexerSubaccountResponse;
    }>;
    getOrder(orderId: string): Promise<IndexerSubaccountOrder>;
    getAllMarkets(): Promise<Record<string, IndexerPerpetualMarket>>;
    private getSubaccountInfo;
}
export {};
