import {
  type IndexerSubaccountBatchUpdateMessage,
  type IndexerSubaccountSubscribedMessage,
  type IndexerMarketBatchUpdateMessage,
  type IndexerMarketSubscribedMessage,
  type IndexerTradeBatchUpdateMessage,
  type IndexerTradeSubscribedMessage,
  type IndexerOrderbookBatchUpdateMessage,
  type IndexerOrderbookSubscribedMessage,
  type IndexerCandlesBatchUpdateMessage,
  type IndexerCandlesSubscribedMessage,
  MessageChannel,
  MessageType,
  type WebSocketMessage,
} from "@klyra/shared";
import { type Store } from "../core/store";
import { type StoreState } from "../types/store";
import { MarketsProcessor } from "./markets.processor";
import { TradesProcessor } from "./trades.processor";
import { OrderbooksProcessor } from "./orderbooks.processor";
import { CandlesProcessor } from "./candles.processor";
import { AccountProcessor } from "./account/account.processor";

export class MessageProcessor {
  private accountProcessor: AccountProcessor;
  private marketsProcessor: MarketsProcessor;
  private tradesProcessor: TradesProcessor;
  private orderbooksProcessor: OrderbooksProcessor;
  private candlesProcessor: CandlesProcessor;

  constructor(store: Store) {
    this.accountProcessor = new AccountProcessor(store);
    this.marketsProcessor = new MarketsProcessor(store);
    this.tradesProcessor = new TradesProcessor(store);
    this.orderbooksProcessor = new OrderbooksProcessor(store);
    this.candlesProcessor = new CandlesProcessor(store);
  }

  process(message: WebSocketMessage<unknown>): void {
    if (message.channel.length === 0) return;

    switch (message.channel) {
      case MessageChannel.MARKETS:
        this.processMarketUpdate(message);
        break;
      case MessageChannel.TRADES:
        this.processTradeUpdate(message);
        break;
      case MessageChannel.ORDERBOOK:
        this.processOrderbookUpdate(message);
        break;
      case MessageChannel.CANDLES:
        this.processCandleUpdate(message);
        break;
      case MessageChannel.PARENT_SUBACCOUNTS:
        this.processAccountUpdate(message);
        break;
      default:
        throw new Error(`Unsupported message channel: ${message.channel}`);
    }
  }

  private processMarketUpdate(msg: WebSocketMessage<unknown>): void {
    if (msg.type === MessageType.CHANNEL_BATCH_DATA) {
      this.marketsProcessor.processBatchUpdate(
        msg as IndexerMarketBatchUpdateMessage
      );
    } else if (msg.type === MessageType.SUBSCRIBED) {
      this.marketsProcessor.processSubscribed(
        msg as IndexerMarketSubscribedMessage
      );
    }
  }

  private processTradeUpdate(
    msg: WebSocketMessage<unknown>
  ): Partial<StoreState> {
    if (msg.type === MessageType.CHANNEL_BATCH_DATA) {
      this.tradesProcessor.processBatchUpdate(
        msg as IndexerTradeBatchUpdateMessage
      );
    } else if (msg.type === MessageType.SUBSCRIBED) {
      this.tradesProcessor.processSubscribed(
        msg as IndexerTradeSubscribedMessage
      );
    }

    return {};
  }

  private processOrderbookUpdate(
    msg: WebSocketMessage<unknown>
  ): Partial<StoreState> {
    if (msg.type === MessageType.CHANNEL_BATCH_DATA) {
      this.orderbooksProcessor.processBatchUpdate(
        msg as IndexerOrderbookBatchUpdateMessage
      );
    } else if (msg.type === MessageType.SUBSCRIBED) {
      this.orderbooksProcessor.processSubscribed(
        msg as IndexerOrderbookSubscribedMessage
      );
    }

    return {};
  }

  private processAccountUpdate(
    msg: WebSocketMessage<unknown>
  ): Partial<StoreState> {
    if (msg.type === MessageType.CHANNEL_BATCH_DATA) {
      this.accountProcessor.processBatchUpdate(
        msg as IndexerSubaccountBatchUpdateMessage
      );
    } else if (msg.type === MessageType.SUBSCRIBED) {
      this.accountProcessor.processSubscribed(
        msg as IndexerSubaccountSubscribedMessage
      );
    }

    return {};
  }

  private processCandleUpdate(
    msg: WebSocketMessage<unknown>
  ): Partial<StoreState> {
    if (msg.type === MessageType.CHANNEL_BATCH_DATA) {
      this.candlesProcessor.processBatchUpdate(
        msg as IndexerCandlesBatchUpdateMessage
      );
    } else if (msg.type === MessageType.SUBSCRIBED) {
      this.candlesProcessor.processSubscribed(
        msg as IndexerCandlesSubscribedMessage
      );
    }

    return {};
  }
}
