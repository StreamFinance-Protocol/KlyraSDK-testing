import { OrderSide } from "@klyra/shared";
import { type Store } from "../../../core/store";
import {
  type TradeFormSummary,
  TradeFormType,
  type TradeFormInputs,
  type Subaccount,
  type MarketTradeFormInputs,
  type LimitTradeFormInputs,
  MarginMode,
  type Market,
} from "../../../types";
import { getOrderbookFromStore } from "../../../utils/orderbook";
import { getMarginModeFromSubaccount } from "../../../utils/indexer-conversion";

export class TradeFormSummaryCalculator {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  calculate(
    calculationResult: TradeFormInputs,
    subaccount: Subaccount
  ): TradeFormSummary | null {
    const multiplier = calculationResult.side === OrderSide.BUY ? 1 : -1;
    const market = this.store.getState().markets[calculationResult.marketId];
    if (!market) return null;

    switch (calculationResult.type) {
      case TradeFormType.MARKET: {
        // TODO: get fee rate from user
        const feeRate: number | null = 0;
        const values = calculationResult as MarketTradeFormInputs;
        // const midMarketPrice = this.orderbookMidPrice(
        //   calculationResult.marketId
        // );
        // const worstPrice = calculationResult.worstPrice;
        // const slippageFromMidPrice = ...
        const price = values.internal?.price ?? 0;
        const side = values.side;
        // TODO: set custom slippage
        const maxSlippage = 0.01;
        let payloadPrice = null;
        if (price) {
          payloadPrice =
            side === OrderSide.BUY
              ? price * (1 + maxSlippage)
              : price * (1 - maxSlippage);
        }

        const quoteSize = values.quoteSize;
        const baseSize = price && quoteSize ? price * quoteSize : null;
        const fee = baseSize && feeRate ? baseSize * feeRate : null;
        // TODO: check if the -1 is correct
        const total = baseSize ? baseSize * multiplier + (fee ?? 0) * -1 : null;

        const spotPrice = market.spotPrice;
        const priceDiff = this.slippage(price, spotPrice, side);
        // TODO: check if we should round here (abacus does, but if we do it breaks the number)
        // const indexSlippage =
        //   priceDiff && spotPrice ?
        //      Rounder.quickRound(priceDiff / spotPrice, SLIPPAGE_STEP_SIZE)
        //     : null;
        const indexSlippage =
          priceDiff && spotPrice ? priceDiff / spotPrice : null;

        const filled = values.internal?.filled ?? false;
        // TODO: These are the current values. Ideally, we would calculate the new values and send both to the frontend.
        const positionMargin = this.getPositionMargin(
          values.marginMode,
          market,
          subaccount
        );
        // const positionLeverage = this.getPositionLeverage(market, subaccount);
        // TODO: calculate new account equity

        return {
          price,
          payloadPrice,
          baseSize,
          quoteSize,
          fee,
          feeRate,
          total,
          // slippage: slippageFromMidPrice,
          filled,
          indexSlippage,
          positionMargin,
        };
      }

      case TradeFormType.LIMIT: {
        const values = calculationResult as LimitTradeFormInputs;
        // const timeInForce = values.timeInForce;
        // const execution = values.execution;
        // const isMaker =
        //   timeInForce === OrderTimeInForce.GTT ||
        //   execution === OrderExecution.POST_ONLY;

        // TODO: get fee rate from user
        const feeRate: number | null = 0;
        const price = values.price;
        const quoteSize = values.quoteSize;
        const baseSize = price && quoteSize ? price * quoteSize : null;
        const fee = baseSize && feeRate ? baseSize * feeRate : null;
        const total = baseSize ? baseSize * multiplier + (fee ?? 0) * -1 : null;

        const positionMargin = this.getPositionMargin(
          values.marginMode,
          market,
          subaccount
        );
        // const positionLeverage = this.getPositionLeverage(market, subaccount);
        // TODO: calculate new account equity

        return {
          price,
          payloadPrice: price,
          baseSize,
          quoteSize,
          fee,
          feeRate,
          total,
          filled: true,
          positionMargin,
        };
      }

      default:
        return null;
    }
  }

  private orderbookMidPrice(marketId: string): number | null {
    const orderbook = getOrderbookFromStore(this.store, marketId);

    const asks = orderbook.asks;
    const bids = orderbook.bids;

    const firstAsk = asks[0];
    const firstBid = bids[0];

    if (!firstAsk || !firstBid) return null;

    const midPrice = (firstAsk.price + firstBid.price) / 2;

    return midPrice;
  }

  private slippage(
    price: number,
    spotPrice: number,
    side: OrderSide
  ): number | null {
    if (!price || !spotPrice) return null;

    return side === OrderSide.BUY ? price - spotPrice : spotPrice - price;
  }

  private getPositionMargin(
    marginMode: MarginMode,
    market: Market,
    subaccount: Subaccount
  ): number | null {
    const position = subaccount.openPositions?.[market.id];
    if (!position) return null;

    if (marginMode === MarginMode.CROSS) {
      const currentNotionalTotal = position.notionalTotal;
      const mmf = market.configs.maintenanceMarginFraction;

      if (mmf && currentNotionalTotal) {
        return currentNotionalTotal * mmf;
      }
    } else {
      const currentEquity = position.equity;

      if (currentEquity) {
        return currentEquity;
      }
    }

    return null;
  }

  private getPositionLeverage(
    market: Market,
    subaccount: Subaccount
  ): number | null {
    const { subaccountNumber, leverage, openPositions } = subaccount;

    const marginMode = getMarginModeFromSubaccount(subaccountNumber);

    if (marginMode === MarginMode.ISOLATED) {
      return leverage ?? null;
    }

    const marketId = market.id;
    const position = openPositions?.[marketId];

    const currentLeverage = position?.leverage;
    return currentLeverage ?? null;
  }

  private getExecutionPrice(
    spotPrice: number,
    limitPrice: number,
    isBuying: boolean
  ): number | null {
    if (!spotPrice || !limitPrice) return null;

    if (isBuying) {
      return Math.min(spotPrice, limitPrice);
    }
    return Math.max(spotPrice, limitPrice);
  }
}
