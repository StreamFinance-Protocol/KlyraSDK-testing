import { OrderTimeInForce, OrderSide, OrderStatusEnum } from "@klyra/shared";
import { MAX_SUBACCOUNT_NUMBER, NUM_PARENT_SUBACCOUNTS } from "@klyra/shared";
import { type Store } from "../../../core/store";
import { type Market } from "../../../types/markets";
import { type Subaccount } from "../../../types/accounts";
import { validateTradeForm } from "../../../schemas/trade-forms";
import {
  type BaseForm,
  FormType,
  type LimitTradeFormInputs,
  type MarketTradeFormInputs,
  type TradeForm,
  type TradeFormInputs,
  type TradeFormInputsKeys,
  type TradeFormSummary,
  TradeFormType,
  type TradeFormOptions,
} from "../../../types/forms";
import { quickRound, round } from "../../../utils/rounder";
import { getOrderbookFromStore } from "../../../utils/orderbook";
import { BaseFormProcessor } from "../base-form.processor";
import { DEFAULT_TRADE_FORM_STATE } from "./values";
import { TradeFormSummaryCalculator } from "./trade-form-summary.calculator";
import { TradeFormOptionsCalculator } from "./trade-form-options.calculator";

interface MarketOrder {
  baseSizeTotal: number;
  quoteSizeTotal: number;
  filled: boolean;
  worstPrice: number | null;
}

export class TradeFormProcessor extends BaseFormProcessor {
  private optionsProcessor: TradeFormOptionsCalculator;
  private summaryProcessor: TradeFormSummaryCalculator;

  constructor(store: Store) {
    super(store, FormType.TRADE);
    this.optionsProcessor = new TradeFormOptionsCalculator(store);
    this.summaryProcessor = new TradeFormSummaryCalculator(store);
  }

  public resetForm(): void {
    this.updateForm(DEFAULT_TRADE_FORM_STATE);
  }

  public processInput(fieldName: TradeFormInputsKeys, value: unknown): void {
    const { inputs } = this.getCurrentFormState() as BaseForm<
      TradeFormInputs,
      TradeFormSummary,
      TradeFormOptions
    >;
    const { subaccountNumber, account } = this.store.getState().user;
    const subaccount = account.subaccounts[subaccountNumber];
    if (!subaccount) {
      throw new Error(`Subaccount number ${subaccountNumber} not found.`);
    }

    // create an internal copy of the inputs state so we can manipulate it without side effects
    const newInputs: TradeFormInputs = { ...inputs, [fieldName]: value };
    this.updateForm({ inputs: newInputs });
    // validate the inputs

    const newOptions = this.optionsProcessor.calculate(newInputs);
    this.updateForm({ options: newOptions });

    const validationResult = this.validateInputs(newInputs);
    // if the inputs are invalid, set the errors in the store and return
    if (!validationResult.isValid) {
      // TODO: better error schema
      const errors = validationResult.errors.reduce<Record<string, string>>(
        (acc, error) => {
          if ("field" in error && "error" in error) {
            acc[(error as { field: string }).field] = (
              error as { error: string }
            ).error;
          }
          return acc;
        },
        {}
      );

      if (Object.keys(errors).length > 0) {
        this.updateForm({ errors });
        return;
      }
    }

    const calculationResult = this.calculateFormResult(
      newInputs,
      fieldName,
      subaccount
    );
    if (!calculationResult) return;

    const summary = this.summaryProcessor.calculate(
      calculationResult,
      subaccount
    );
    if (!summary) return;

    this.updateForm({
      inputs: calculationResult,
      postResults: {},
      summary,
    });
  }

  protected validateInputs(inputs: TradeFormInputs): {
    isValid: boolean;
    errors: object[];
  } {
    const errors: object[] = [];

    // validate agains the schema using zod
    const validationResult = validateTradeForm(inputs);
    if (!validationResult.success) {
      errors.push({ field: "inputs", error: validationResult.error.message });
    }

    // TODO: make other validations

    return { isValid: errors.length === 0, errors };
  }

  protected calculateFormResult(
    newInputs: TradeFormInputs,
    fieldName: TradeFormInputsKeys,
    subaccount: Subaccount
  ): TradeFormInputs | null {
    const isBuying = newInputs.side !== OrderSide.SELL;

    switch (newInputs.type) {
      case TradeFormType.MARKET:
      case TradeFormType.STOP_MARKET:
      case TradeFormType.TAKE_PROFIT_MARKET:
        return this.calculateMarketOrder(
          newInputs,
          fieldName,
          subaccount,
          isBuying
        );

      case TradeFormType.LIMIT:
      case TradeFormType.STOP_LIMIT:
      case TradeFormType.TAKE_PROFIT_LIMIT:
        return this.calculateLimitOrder(
          newInputs,
          fieldName,
          subaccount,
          isBuying
        );

      default:
        return null;
    }
  }

  private calculateMarketOrder(
    newInputs: MarketTradeFormInputs,
    fieldName: TradeFormInputsKeys,
    subaccount: Subaccount,
    isBuying: boolean
  ): MarketTradeFormInputs {
    const { marketId, baseSize, quoteSize } = newInputs;
    const storeState = this.store.getState();
    const newMarketOrder: MarketTradeFormInputs = { ...newInputs };

    const market = storeState.markets[marketId];
    if (!market) throw new Error(`Market ${marketId} not found.`);

    let marketOrder: {
      baseSizeTotal: number;
      quoteSizeTotal: number;
      filled: boolean;
      worstPrice: number | null;
    } | null = null;

    if (fieldName === "baseSize") {
      marketOrder = this.calculateMarketOrderFromBaseSize(
        baseSize,
        market,
        isBuying
      );
    } else if (fieldName === "quoteSize") {
      marketOrder = this.calculateMarketOrderFromQuoteSize(
        quoteSize,
        market,
        isBuying
      );
    } else if (fieldName === "leverage") {
      const leverage = newInputs.leverage ?? 0;

      marketOrder = this.calculateMarketOrderFromLeverage(
        leverage,
        market,
        subaccount
      );
    }

    if (marketOrder) {
      newMarketOrder.baseSize = marketOrder.baseSizeTotal;
      newMarketOrder.quoteSize = marketOrder.quoteSizeTotal;
      const internal = { ...newMarketOrder.internal };

      internal.filled = marketOrder.filled;
      internal.worstPrice = marketOrder.worstPrice ?? undefined;

      newMarketOrder.internal = internal;
    }

    if (newMarketOrder.baseSize && newMarketOrder.quoteSize) {
      newMarketOrder.internal = {
        ...newMarketOrder.internal,
        price: newMarketOrder.baseSize / newMarketOrder.quoteSize,
      };
    }

    return newMarketOrder;
  }

  private calculateMarketOrderFromLeverage(
    leverage: number,
    market: Market,
    subaccount: Subaccount
  ): MarketOrder | null {
    const stepSize = market.configs.stepSize;
    const equity = subaccount.equity;
    const spotPrice = market.spotPrice;
    // TODO: get user fee rate --- const feeRate = user.takerFeeRate;
    const positions = subaccount.openPositions;
    const positionSize = positions?.[market.id]?.size;

    if (!equity || !spotPrice || !positionSize || equity <= 0) return null;

    const existingLeverage = (positionSize * spotPrice) / equity;
    let isBuying = null;
    if (leverage > existingLeverage) {
      isBuying = true;
    } else if (existingLeverage > leverage) {
      isBuying = false;
    }

    if (isBuying === null) return null;

    const orderbookField: "asks" | "bids" = isBuying ? "asks" : "bids";
    const orderbook = getOrderbookFromStore(this.store, market.market)[
      orderbookField
    ];

    let quoteSizeTotal = 0;
    let baseSizeTotal = 0;
    let worstPrice: number | null = null;
    let filled = false;
    const marketOrderOrderBook = [];

    const orderbookFirstOrNull = orderbook[0] ?? null;
    const currentPositionValue =
      positionSize * (orderbookFirstOrNull?.price ?? 0) || 0;
    const targetPositionValue = leverage * equity;
    let remainingOrderSize = targetPositionValue - currentPositionValue;

    if (
      (isBuying && remainingOrderSize < 0) ||
      (!isBuying && remainingOrderSize > 0)
    ) {
      // The order would decrease leverage, which is not what we want for a "leverage" input
      return null;
    }

    for (const entry of orderbook) {
      const { price, size } = entry;

      const orderSize =
        Math.abs(remainingOrderSize) > size * price
          ? size
          : Math.abs(remainingOrderSize) / price;

      const roundedOrderSize = quickRound(orderSize, stepSize);

      quoteSizeTotal += roundedOrderSize;
      const orderCost = roundedOrderSize * price;
      baseSizeTotal += orderCost;
      worstPrice = price;

      marketOrderOrderBook.push(entry);

      remainingOrderSize -= isBuying ? orderCost : -orderCost;

      if (Math.abs(remainingOrderSize) < price * stepSize) {
        filled = true;
        break;
      }
    }

    return {
      quoteSizeTotal,
      baseSizeTotal,
      worstPrice,
      filled,
    };
  }

  private calculateMarketOrderFromBaseSize(
    baseSize: number | undefined,
    market: Market,
    isBuying: boolean
  ): MarketOrder | null {
    if (!baseSize) return null;
    // const stepSize = market.configs.stepSize;
    const orderbookField: "asks" | "bids" = isBuying ? "asks" : "bids";
    const orderbook = getOrderbookFromStore(this.store, market.market)[
      orderbookField
    ];

    if (orderbook.length === 0) return null;

    let quoteSizeTotal = 0;
    let baseSizeTotal = 0;
    let worstPrice: number | null = null;
    let filled = false;
    const marketOrderOrderBook = [];

    for (const entry of orderbook) {
      const { price, size } = entry;

      if (price && price > 0 && size) {
        const entryBaseSize = size * price;
        filled = baseSizeTotal + entryBaseSize >= baseSize;

        let matchedQuoteSize = size;
        let matchedBaseSize = entryBaseSize;

        if (filled) {
          matchedBaseSize = baseSize - baseSizeTotal;
          matchedQuoteSize = matchedBaseSize / price;
          // TODO: check if we should round here (abacus does, but if we do it breaks the number)
          // matchedQuoteSize = quickRound(matchedQuoteSize, stepSize);
          matchedBaseSize = matchedQuoteSize * price;
        }

        quoteSizeTotal += matchedQuoteSize;
        baseSizeTotal += matchedBaseSize;

        worstPrice = price;
        marketOrderOrderBook.push(entry);

        if (filled) {
          break;
        }
      }
    }

    return {
      quoteSizeTotal,
      baseSizeTotal,
      worstPrice,
      filled,
    };
  }

  private calculateMarketOrderFromQuoteSize(
    quoteSize: number | undefined,
    market: Market,
    isBuying: boolean
  ): MarketOrder | null {
    if (!quoteSize) return null;
    const orderbookField: "asks" | "bids" = isBuying ? "asks" : "bids";
    const orderbook = getOrderbookFromStore(this.store, market.market)[
      orderbookField
    ];

    if (orderbook.length === 0) return null;

    let quoteSizeTotal = 0;
    let baseSizeTotal = 0;
    let worstPrice: number | null = null;
    let filled = false;
    const marketOrderOrderBook = [];

    for (const entry of orderbook) {
      const { price, size } = entry;

      if (price && size) {
        filled = quoteSizeTotal + size >= quoteSize;
        const matchedQuoteSize = filled ? quoteSize - quoteSizeTotal : size;
        const matchedBaseSize = matchedQuoteSize * price;

        quoteSizeTotal += matchedQuoteSize;
        baseSizeTotal += matchedBaseSize;

        worstPrice = price;
        marketOrderOrderBook.push(entry);

        if (filled) {
          break;
        }
      }
    }

    return {
      quoteSizeTotal,
      baseSizeTotal,
      worstPrice,
      filled,
    };
  }

  private calculateLimitOrder(
    newInputs: LimitTradeFormInputs,
    fieldName: TradeFormInputsKeys,
    subaccount: Subaccount,
    isBuying: boolean
  ): LimitTradeFormInputs {
    const { marketId, price, baseSize, quoteSize, leverage } = newInputs;
    const storeState = this.store.getState();
    const newLimitOrder: LimitTradeFormInputs = { ...newInputs };
    const market = storeState.markets[marketId];
    if (!market) throw new Error(`Market ${marketId} not found.`);
    const stepSize = market.configs.stepSize;

    if (fieldName === "baseSize") {
      if (price && baseSize) {
        newLimitOrder.quoteSize = round(baseSize / price, stepSize);
      }
    } else if (fieldName === "quoteSize") {
      if (price && quoteSize) {
        newLimitOrder.baseSize = round(quoteSize * price, stepSize);
      }
    } else if (fieldName === "price") {
      if (price) {
        if (newLimitOrder.baseSize) {
          newLimitOrder.quoteSize = round(
            newLimitOrder.baseSize / price,
            stepSize
          );
        } else if (newLimitOrder.quoteSize) {
          newLimitOrder.baseSize = round(
            newLimitOrder.quoteSize * price,
            stepSize
          );
        }
      }
    } else if (fieldName === "leverage") {
      if (leverage) {
        const calculatedSize = this.calculateSizeFromLeverageAndLimitPrice(
          leverage,
          price,
          market,
          subaccount,
          isBuying
        );
        if (calculatedSize) {
          newLimitOrder.quoteSize = calculatedSize;
          newLimitOrder.baseSize = calculatedSize * price;
        }
      }
    }

    return newLimitOrder;
  }

  private calculateSizeFromLeverageAndLimitPrice(
    leverage: number | undefined,
    limitPrice: number | undefined,
    market: Market,
    subaccount: Subaccount,
    isBuying: boolean
  ): number | null {
    if (!leverage || !limitPrice) return null;

    const equity = subaccount.equity;
    // TODO: get user fee rate
    const feeRate = 0;
    const stepSize = market.configs.stepSize;

    const positions = subaccount.openPositions;
    const positionQuoteSize = positions?.[market.id]?.size;
    const orderSign = isBuying ? 1 : -1;

    if (!equity || !positionQuoteSize) return null;

    const orderSize =
      (leverage * equity - positionQuoteSize * limitPrice) /
      (limitPrice + orderSign * leverage * limitPrice * feeRate);

    const desiredSize = Math.abs(orderSize);
    if (desiredSize < positionQuoteSize) {
      return quickRound(orderSize, stepSize);
    }
    const rounded = quickRound(desiredSize, stepSize);
    return quickRound(rounded, stepSize);
  }

  private updateForm(newState: Partial<TradeForm>): void {
    const formType = this.formType;
    const forms = this.store.getState().forms;

    this.store.setState({
      forms: {
        ...forms,
        [formType]: { ...forms[formType], ...newState },
      },
    });
  }

  private isShortTermOrder(
    type: TradeFormType,
    timeInForce?: OrderTimeInForce
  ): boolean {
    if (type === TradeFormType.MARKET) {
      return true;
    } else if (type === TradeFormType.LIMIT) {
      if (timeInForce === OrderTimeInForce.GTT) {
        return false;
      }
      return true;
    }
    return false;
  }

  // public convertToPayload(
  //   subaccountNumber: number,
  //   TODO: get currentHeight from other places (indexer and store on state for example)
  //   currentHeight: number
  // ): PlaceOrderPayload {
  //   const state = this.store.getState();
  //   const tradeForm = state.forms[FormType.TRADE];
  //   const tradeInputs = tradeForm.inputs;

  //   // random number between 0 and 2^32 - 1
  //   const clientId = Math.floor(Math.random() * (Number.MAX_SAFE_INTEGER - 1));

  //   const orderSubaccountNumber =
  //     tradeInputs.marginMode === MarginMode.ISOLATED
  //       ? this.getSubaccountNumberForIsolatedMarket(
  //           tradeInputs.marketId,
  //           subaccountNumber
  //         )
  //       : subaccountNumber;

  //   const market = state.markets[tradeInputs.marketId];
  //   if (!market) throw new Error(`Market ${tradeInputs.marketId} not found.`);

  //   const marketInfo: PlaceOrderMarketInfo = {
  //     clobPairId: market.configs.clobPairId,
  //     atomicResolution: market.configs.atomicResolution,
  //     stepBaseQuantums: market.configs.stepBaseQuantums,
  //     quantumConversionExponent: market.configs.quantumConversionExponent,
  //     subticksPerTick: market.configs.subticksPerTick,
  //   };

  //   // TODO: get triggerPrice if needed
  //   const triggerPrice = 0;
  //   // TODO: get postOnly if needed
  //   const postOnly = false;
  //   const reduceOnly = tradeInputs.reduceOnly || false;

  //   const timeInForce = !!tradeInputs.timeInForce
  //     ? tradeInputs.type === TradeFormType.MARKET
  //       ? OrderTimeInForce.IOC
  //       : tradeInputs.timeInForce || OrderTimeInForce.IOC
  //     : null;

  //   const execution = tradeInputs.execution || OrderExecution.DEFAULT;

  //   // TODO: calculate goodTilTimeInSeconds
  //   const goodTilTimeInSeconds = tradeInputs.goodTilTime || null;

  //   const goodTilBlock = this.isShortTermOrder(
  //     tradeInputs.type,
  //     tradeInputs.timeInForce
  //   )
  //     ? currentHeight + SHORT_TERM_ORDER_DURATION
  //     : null;

  //   return {
  //     subaccountNumber: orderSubaccountNumber,
  //     marketId: tradeInputs.marketId,
  //     clientId,
  //     type: tradeInputs.type,
  //     side: tradeInputs.side,
  //     price: tradeForm.summary?.price || 0,
  //     // TODO: check if it's baseSize or quoteSize
  //     size: tradeForm.summary?.baseSize || 0,
  //     triggerPrice,
  //     reduceOnly,
  //     postOnly,
  //     marketInfo,
  //     timeInForce,
  //     execution,
  //     goodTilTimeInSeconds,
  //     goodTilBlock,
  //     currentHeight,
  //   };
  // }

  private getSubaccountNumberForIsolatedMarket(
    marketId: string,
    subaccountNumber: number
  ): number {
    const subaccounts = this.store.getState().user.account.subaccounts;

    const utilizedSubaccountsMarketIdMap: Record<string, string[]> =
      Object.entries(subaccounts).reduce<Record<string, string[]>>(
        (acc, [_, subaccount]) => {
          const openPositions = subaccount.openPositions;
          const openOrders = subaccount.orders?.filter((order) => {
            const status = order.status;

            return [
              OrderStatusEnum.OPEN,
              OrderStatusEnum.PENDING,
              OrderStatusEnum.UNTRIGGERED,
              OrderStatusEnum.PARTIALLY_FILLED,
            ].includes(status.value);
          });

          const positionMarketIds = Object.values(openPositions ?? {}).map(
            (position) => position.id
          );
          const openOrderMarketIds = (openOrders ?? []).map(
            (order) => order.marketId
          );

          const uniqueMarketIds = [
            ...new Set([...positionMarketIds, ...openOrderMarketIds]),
          ];

          acc[subaccountNumber] = uniqueMarketIds;
          return acc;
        },
        {}
      );

    let availableSubaccountNumber = subaccountNumber;
    Object.entries(utilizedSubaccountsMarketIdMap).forEach(
      ([key, marketIds]) => {
        const subaccountNumberToCheck = parseInt(key);
        if (subaccountNumberToCheck !== subaccountNumber) {
          if (marketIds.includes(marketId) && marketIds.length <= 1) {
            return subaccountNumberToCheck;
          } else if (marketIds.length === 0) {
            const equity = subaccounts[subaccountNumberToCheck]?.equity ?? 0;
            if (
              availableSubaccountNumber === subaccountNumber &&
              equity === 0
            ) {
              availableSubaccountNumber = subaccountNumberToCheck;
            }
          }
        }
      }
    );

    if (availableSubaccountNumber !== subaccountNumber) {
      return availableSubaccountNumber;
    }

    const existingSubaccountNumbers = Object.keys(
      utilizedSubaccountsMarketIdMap
    );

    for (
      let offset = NUM_PARENT_SUBACCOUNTS;
      offset <= MAX_SUBACCOUNT_NUMBER;
      offset += NUM_PARENT_SUBACCOUNTS
    ) {
      const tentativeSubaccountNumber = offset + subaccountNumber;
      if (
        !existingSubaccountNumbers.includes(
          tentativeSubaccountNumber.toString()
        )
      ) {
        return tentativeSubaccountNumber;
      }
    }

    throw new Error("No available subaccount number");
  }
}
