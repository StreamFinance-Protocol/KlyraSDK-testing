import {
  OrderTimeInForce,
  OrderExecution,
  OrderStatusEnum,
} from "@klyra/shared";
import {
  PerpetualMarketType,
  type TradeFormInputs,
  type TradeFormOptions,
  TradeFormType,
  MarginMode,
  type Subaccount,
} from "../../../types";
import { type Store } from "../../../core/store";
import { DEFAULT_TRADE_FORM_OPTIONS } from "./values";

export class TradeFormOptionsCalculator {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  calculate(formInputs: TradeFormInputs): TradeFormOptions {
    const formType = formInputs.type;
    const typeToFnMap = {
      [TradeFormType.MARKET]: this.getMarketTypeFormOptions.bind(this),
      [TradeFormType.LIMIT]: this.getLimitTypeFormOptions.bind(this),
      [TradeFormType.STOP_LIMIT]: this.getSLTPLimitTypeFormOptions.bind(this),
      [TradeFormType.TAKE_PROFIT_LIMIT]:
        this.getSLTPLimitTypeFormOptions.bind(this),
      [TradeFormType.STOP_MARKET]: this.getSLTPMarketTypeFormOptions.bind(this),
      [TradeFormType.TAKE_PROFIT_MARKET]:
        this.getSLTPMarketTypeFormOptions.bind(this),
    };

    const options = typeToFnMap[formType](formInputs);

    options.needsMarginMode = this.getNeedsMarginMode(formInputs);

    const newOptions = { ...DEFAULT_TRADE_FORM_OPTIONS, ...options };
    return newOptions;
  }

  private getMarketTypeFormOptions(
    _: TradeFormInputs
  ): Partial<TradeFormOptions> {
    const options: Partial<TradeFormOptions> = {};

    options.needsReduceOnly = true;
    options.needsGoodTilTime = true;
    options.needsExecution = true;

    return options;
  }

  private getLimitTypeFormOptions(
    formInputs: TradeFormInputs
  ): Partial<TradeFormOptions> {
    const options: Partial<TradeFormOptions> = {};

    const isGoodTilTime = formInputs.timeInForce === OrderTimeInForce.GTT;

    options.needsPrice = true;
    options.needsTimeInForce = true;
    options.needsGoodTilTime = isGoodTilTime;
    options.needsPostOnly = isGoodTilTime;
    options.needsReduceOnly = !isGoodTilTime;

    return options;
  }

  private getSLTPMarketTypeFormOptions(
    _: TradeFormInputs
  ): Partial<TradeFormOptions> {
    const options: Partial<TradeFormOptions> = {};

    options.needsTriggerPrice = true;
    options.needsGoodTilTime = true;
    options.needsExecution = true;
    options.needsReduceOnly = true;

    return options;
  }

  private getSLTPLimitTypeFormOptions(
    formInputs: TradeFormInputs
  ): Partial<TradeFormOptions> {
    const options: Partial<TradeFormOptions> = {};

    options.needsPrice = true;
    options.needsTriggerPrice = true;
    options.needsGoodTilTime = true;
    options.needsExecution = true;
    options.needsReduceOnly = formInputs.execution === OrderExecution.IOC;

    options.executionOptions = [
      OrderExecution.DEFAULT,
      OrderExecution.IOC,
      OrderExecution.POST_ONLY,
    ];

    return options;
  }

  private getNeedsMarginMode(formInputs: TradeFormInputs): boolean {
    const marketId = formInputs.marketId;
    const store = this.store.getState();
    const { subaccountNumber, account } = store.user;
    const subaccount = account.subaccounts[subaccountNumber];
    const markets = store.markets;
    const existingMarginMode = this.getExistingMarginMode(marketId, subaccount);

    if (existingMarginMode) {
      return false;
    }
    if (marketId) {
      const market = markets[marketId];
      const marketType = market?.configs.perpetualMarketType;
      if (marketType === PerpetualMarketType.CROSS) {
        // if the market is cross, then the user can select either margin mode
        return true;
      }
      // if the market is isolated, then the user can't select cross margin mode
      return false;
    }
    return true;
  }

  private getExistingMarginMode(
    marketId: string,
    subaccount: Subaccount | undefined
  ): MarginMode | null {
    const position = subaccount?.openPositions?.[marketId];
    if (position) {
      return position.marginMode ?? null;
    }

    const openOrder = subaccount?.orders?.find(
      (order) =>
        order.marketId === marketId &&
        order.status.value === OrderStatusEnum.OPEN
    );
    if (openOrder) {
      if (openOrder.subaccountNumber !== subaccount?.subaccountNumber) {
        // if the order is not from the subaccount, then it's isolated
        return MarginMode.ISOLATED;
      }
      // if the order is from the subaccount, then it's cross
      return MarginMode.CROSS;
    }

    return null;
  }
}
