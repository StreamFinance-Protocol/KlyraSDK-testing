import {
  type IndexerCandleContents,
  type IndexerCandleResolution,
  type IndexerCandlesBatchUpdateMessage,
  type IndexerCandlesSubscribedMessage,
} from "@klyra/shared";
import { type Store } from "../core/store";
import { transform } from "../utils/merge";
import { type MarketCandle } from "../types/markets";
import { type BaseProcessor } from "./base.processor";

export class CandlesProcessor implements BaseProcessor {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  public processSubscribed(msg: IndexerCandlesSubscribedMessage): void {
    const { marketId, resolution } = this.getMarketAndResolution(msg.id);

    const payload = msg.contents.candles;

    const modified = payload.reverse().map(this.processCandle.bind(this));

    this.updateCandles(marketId, resolution, modified);
  }

  // Even though this is a batch update, we only want to update the last candle
  // because the indexer will send the latest candle for a given resolution
  // and time period.
  public processBatchUpdate(msg: IndexerCandlesBatchUpdateMessage): void {
    const { marketId, resolution } = this.getMarketAndResolution(msg.id);
    const existingCandles = this.store.getState().candles;
    const payload = msg.contents;

    const newCandlesArray = existingCandles[marketId]?.[resolution] ?? [];

    const lastExistingCandle =
      newCandlesArray[newCandlesArray.length - 1] ?? null;
    const lastExistingCandleTimestamp =
      lastExistingCandle?.startedAtMilliseconds ?? 0;
    for (const candle of payload) {
      const newCandle = this.processCandle(candle);
      const newCandleTimestamp = newCandle.startedAtMilliseconds;

      if (newCandleTimestamp === lastExistingCandleTimestamp) {
        newCandlesArray.pop();
      }

      newCandlesArray.push(newCandle);
    }

    this.updateCandles(marketId, resolution, newCandlesArray);
  }

  private getMarketAndResolution(id: string | undefined): {
    marketId: string;
    resolution: IndexerCandleResolution;
  } {
    if (!id) throw new Error("No id provided");

    const [marketId, resolution] = id.split("/");
    const resolutionEnum = resolution as IndexerCandleResolution;
    return { marketId: marketId!, resolution: resolutionEnum };
  }

  private processCandle(payload: IndexerCandleContents): MarketCandle {
    return transform<MarketCandle>(undefined, payload, {
      number: {
        low: "low",
        high: "high",
        open: "open",
        close: "close",
        baseTokenVolume: "baseTokenVolume",
        usdVolume: "usdVolume",
        trades: "trades",
      },
      datetime: {
        startedAt: "startedAtMilliseconds",
        updatedAt: "updatedAtMilliseconds",
      },
    });
  }

  private updateCandles(
    marketId: string,
    resolution: string,
    candles: MarketCandle[]
  ): void {
    const existingCandles = this.store.getState().candles;
    this.store.setState({
      candles: {
        ...existingCandles,
        [marketId]: {
          ...existingCandles[marketId],
          [resolution]: candles,
        },
      },
    });
  }
}
