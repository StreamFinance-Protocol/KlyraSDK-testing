import {
  type IndexerMarketSubscribedMessage,
  IndexerPerpetualMarketStatus,
  type IndexerPerpetualMarket,
  type IndexerMarketBatchUpdateMessage,
  type IndexerOraclePriceMarket,
  type IndexerTradingPerpetualMarket,
} from "@klyra/shared";
import { type Store } from "../core/store";
import { CANDLE_OPTIONS } from "../constants/candles";
import {
  type Market,
  type MarketConfigs,
  type PerpetualMarketInfo,
} from "../types/markets";
import { transform } from "../utils/merge";
import { getAssetIdFromMarketId } from "../utils/market-id";

export class MarketsProcessor {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  public processSubscribed(msg: IndexerMarketSubscribedMessage): void {
    const newMarkets = new Map<string, Market>();

    for (const [id, payload] of Object.entries(msg.contents.markets)) {
      const newMarket = this.processSubscribedMarket(id, payload);
      if (newMarket) newMarkets.set(id, newMarket);
    }

    const newMarketsObj = Object.fromEntries(newMarkets);
    this.updateMarkets(newMarketsObj);
  }

  public processBatchUpdate(msg: IndexerMarketBatchUpdateMessage): void {
    const newMarkets = new Map<string, Market>();

    // TODO: change indexer structure so we don't have to do this
    // or check why this is the structure we're receiving
    msg.contents.forEach((partialUpdate) => {
      if (partialUpdate.oraclePrices) {
        for (const [id, payload] of Object.entries(
          partialUpdate.oraclePrices
        )) {
          const newMarket = this.processBatchUpdateMarketOraclePrices(
            id,
            payload
          );
          if (newMarket) newMarkets.set(id, newMarket);
        }
      }

      if (partialUpdate.trading) {
        for (const [id, payload] of Object.entries(partialUpdate.trading)) {
          const newMarket = this.processBatchUpdateMarketTrading(id, payload);
          if (newMarket) newMarkets.set(id, newMarket);
        }
      }
    });

    const newMarketsObj = Object.fromEntries(newMarkets);
    this.updateMarkets(newMarketsObj);
  }

  private processSubscribedMarket(
    id: string,
    payload: IndexerPerpetualMarket
  ): Market | null {
    const existingMarket = this.store.getState().markets[id];
    const newMarket = transform<Market>(existingMarket, payload, {
      string: {
        ticker: "market",
      },
      number: {
        spotPrice: "spotPrice",
        priceChange24H: "priceChange24H",
      },
    });

    if (newMarket.market) {
      newMarket.id = newMarket.market;
      const assetId = getAssetIdFromMarketId(newMarket.market);
      if (assetId) newMarket.assetId = assetId;
    } else {
      const name = payload.ticker;
      newMarket.market = name;
    }

    newMarket.status = this.calculateMarketStatus(payload.status);
    newMarket.configs = this.calculateMarketConfigs(existingMarket, payload);
    newMarket.perpetual = this.calculatePerpetualMarketInfo(
      existingMarket,
      payload,
      newMarket.spotPrice
    );

    // TODO: calculate sparkline

    const effectiveIMF =
      this.calculateEffectiveInitialMarginFraction(newMarket);
    if (effectiveIMF) {
      newMarket.configs.effectiveInitialMarginFraction = effectiveIMF;
    }

    return this.calculateMarket(newMarket);
  }

  private processBatchUpdateMarketOraclePrices(
    id: string,
    payload: IndexerOraclePriceMarket
  ): Market | null {
    const existingMarket = this.store.getState().markets[id];
    const newMarket = transform<Market>(existingMarket, payload, {
      number: {
        spotPrice: "spotPrice",
      },
    });

    return newMarket;
  }

  private processBatchUpdateMarketTrading(
    id: string,
    payload: IndexerTradingPerpetualMarket
  ): Market | null {
    const existingMarket = this.store.getState().markets[id];
    const transformed = transform<Market>(existingMarket, payload, {
      number: {
        spotPrice: "spotPrice",
        price: "spotPrice",
      },
      string: {
        market: "market",
        baseAsset: "assetId",
      },
    });
    const newPerpetual = this.calculatePerpetualMarketInfo(
      existingMarket,
      payload,
      transformed.spotPrice
    );

    transformed.perpetual = newPerpetual;
    return this.calculateMarket(transformed);
  }

  // --- subcalculations ---
  private calculateEffectiveInitialMarginFraction(
    market: Market
  ): number | null {
    const spotPrice = market.spotPrice;
    const baseIMF = market.configs.initialMarginFraction;
    const openInterest = market.perpetual.openInterest;
    const openInterestLowerCap = market.perpetual.openInterestLowerCap;
    const openInterestUpperCap = market.perpetual.openInterestUpperCap;

    if (!baseIMF) return null;
    if (
      !spotPrice ||
      !openInterest ||
      !openInterestLowerCap ||
      !openInterestUpperCap
    ) {
      return baseIMF;
    }
    if (openInterestLowerCap === openInterestUpperCap) return baseIMF;

    const openNotional = openInterest * spotPrice;
    const scalingFactor =
      openNotional -
      openInterestLowerCap / openInterestUpperCap -
      openInterestLowerCap;
    const imfIncrease = (1 - baseIMF) * scalingFactor;
    const effectiveIMF = Math.min(baseIMF + Math.max(imfIncrease, 0), 1);

    return effectiveIMF;
  }

  private calculatePerpetualMarketInfo(
    existingMarket: Market | undefined,
    payload: Partial<IndexerPerpetualMarket>,
    spotPrice: number
  ): PerpetualMarketInfo {
    const perpetualObj = transform<PerpetualMarketInfo>(
      existingMarket?.perpetual,
      payload,
      {
        number: {
          volume24H: "volume24H",
          openInterest: "openInterest",
          openInterestLowerCap: "openInterestLowerCap",
          openInterestUpperCap: "openInterestUpperCap",
          nextFundingRate: "nextFundingRate",
          trades24H: "trades24H",
        },
        datetime: {
          nextFundingAt: "nextFundingAtMilliseconds",
        },
      }
    );
    perpetualObj.openInterestUSDC = perpetualObj.openInterest * spotPrice;

    return perpetualObj;
  }

  private calculateMarketConfigs(
    existingMarket: Market | undefined,
    payload: IndexerPerpetualMarket
  ): MarketConfigs {
    const configsObj = transform<MarketConfigs>(
      existingMarket?.configs,
      payload,
      {
        string: {
          marketType: "perpetualMarketType",
        },
        number: {
          maintenanceMarginFraction: "maintenanceMarginFraction",
          stepSize: "stepSize",
          tickSize: "tickSize",
          minOrderSize: "minOrderSize",
          initialMarginFraction: "initialMarginFraction",
          maxPositionSize: "maxPositionSize",
          baselinePositionSize: "baselinePositionSize",
          basePositionNotional: "basePositionNotional",
          clobPairId: "clobPairId",
          atomicResolution: "atomicResolution",
          stepBaseQuantums: "stepBaseQuantums",
          quantumConversionExponent: "quantumConversionExponent",
          subticksPerTick: "subticksPerTick",
        },
      }
    );

    const minOrderSize = configsObj.minOrderSize;
    if (!minOrderSize) {
      configsObj.minOrderSize = Number(payload.stepSize);
    }
    configsObj.candleOptions = CANDLE_OPTIONS;

    return configsObj;
  }

  private calculateMarketStatus(status: IndexerPerpetualMarketStatus): {
    canTrade: boolean;
    canReduce: boolean;
  } {
    switch (status) {
      case IndexerPerpetualMarketStatus.ACTIVE:
        return {
          canTrade: true,
          canReduce: true,
        };
      case IndexerPerpetualMarketStatus.CANCEL_ONLY:
        return {
          canTrade: false,
          canReduce: true,
        };
      default:
        return {
          canTrade: false,
          canReduce: false,
        };
    }
  }

  private updateMarkets(newMarkets: Record<string, Market>): void {
    const markets = this.store.getState().markets;
    this.store.setState({
      markets: {
        ...markets,
        ...newMarkets,
      },
    });
  }

  private calculateMarket(market: Market): Market {
    const { priceChange24H, spotPrice } = market;
    const modified = { ...market };

    let percent = null;
    if (priceChange24H === 0) percent = 0;

    if (priceChange24H && spotPrice && spotPrice > priceChange24H) {
      const basePrice = spotPrice - priceChange24H;
      if (basePrice > 0) percent = priceChange24H / basePrice;
    }

    modified.priceChange24HPercent = percent;

    return modified;
  }
}
