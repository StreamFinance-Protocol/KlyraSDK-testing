import {
  IndexerOrderStatus,
  type IndexerSubaccountOrder,
  OrderStatusEnum,
} from "@klyra/shared";
import { type Store } from "../../core/store";
import { type SubaccountOrder } from "../../types/accounts";
import { getAssetIdFromMarketId } from "../../utils/market-id";
import {
  convertIndexerOrderStatus,
  convertIndexerOrderSide,
  convertIndexerOrderType,
  getMarginModeFromSubaccount,
  convertIndexerTimeInForce,
} from "../../utils/indexer-conversion";
import { getOrderStatusFromEnum } from "../../utils/order-status";

export class OrdersProcessor {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  public process(
    subaccountOrders: SubaccountOrder[],
    payload: IndexerSubaccountOrder[] | undefined,
    subaccountNumber: number
  ): SubaccountOrder[] {
    if (!payload) return [];

    const newOrders = payload
      .map((item) => {
        const id = item.id || item.clientId;
        return this.processOrder(
          subaccountOrders.find((order) => order.id === id) ?? null,
          item,
          subaccountNumber
        );
      })
      .filter((order): order is SubaccountOrder => order !== null);

    return newOrders;
  }

  private processOrder(
    existing: SubaccountOrder | null,
    payload: IndexerSubaccountOrder,
    subaccountNumber: number
  ): SubaccountOrder | null {
    if (!this.shouldUpdate(existing, payload)) {
      return existing;
    }

    const id = payload.id;
    if (!id) return null;

    const type = convertIndexerOrderType(payload.type);
    const side = convertIndexerOrderSide(payload.side);
    const status = convertIndexerOrderStatus(payload.status);
    const marketId = payload.ticker;
    const price = Number(payload.price);
    const size = Number(payload.size);

    if (!marketId || !price || !size) {
      return null;
    }

    const orderFlags = Number(payload.orderFlags);
    const cancelReason = payload.removalReason;

    const totalFilled = Number(payload.totalFilled) || 0;
    const remainingSize = size - totalFilled;

    const updatedAtMilliseconds = payload.updatedAt
      ? new Date(payload.updatedAt).getTime()
      : undefined;
    let modifiedStatus = status;

    if (totalFilled !== 0 && remainingSize !== 0) {
      if (status.value === OrderStatusEnum.OPEN) {
        modifiedStatus = getOrderStatusFromEnum(
          OrderStatusEnum.PARTIALLY_FILLED
        );
      } else if (status.value === OrderStatusEnum.CANCELLED) {
        modifiedStatus = getOrderStatusFromEnum(
          OrderStatusEnum.PARTIALLY_CANCELLED
        );
      }
    }

    if (orderFlags) {
      const isShortTermOrder = orderFlags === 0;
      const isBestEffortCancelled =
        modifiedStatus.value === OrderStatusEnum.CANCELLING;
      // TODO: add types to the cancel reason
      const isUserCancelled =
        cancelReason === "USER_CANCELLED" ||
        cancelReason === "ORDER_REMOVAL_REASON_USER_CANCELLED";

      if (isShortTermOrder && isBestEffortCancelled && !isUserCancelled) {
        modifiedStatus = getOrderStatusFromEnum(OrderStatusEnum.PENDING);
      }
    }

    const marginMode = getMarginModeFromSubaccount(subaccountNumber);
    const assetId = getAssetIdFromMarketId(marketId);

    const order: SubaccountOrder = {
      subaccountNumber,
      id,
      assetId,
      clientId: Number(payload.clientId),
      type,
      side,
      status: modifiedStatus,
      timeInForce: convertIndexerTimeInForce(payload.timeInForce) ?? undefined,
      marketId,
      clobPairId: Number(payload.clobPairId),
      price,
      size,
      triggerPrice: Number(payload.triggerPrice),
      trailingPercent: undefined,
      remainingSize,
      totalFilled,
      goodTilBlock: Number(payload.goodTilBlock),
      goodTilBlockTime: Math.floor(
        new Date(payload.goodTilBlockTime ?? 0).getTime() / 1000
      ), // in seconds
      createdAtHeight: Number(payload.createdAtHeight),
      createdAtMilliseconds: undefined,
      unfillableAtMilliseconds: undefined,
      expiresAtMilliseconds: new Date(payload.goodTilBlockTime ?? 0).getTime(),
      updatedAtMilliseconds,
      postOnly: Boolean(payload.postOnly),
      reduceOnly: Boolean(payload.reduceOnly),
      cancelReason,
      marginMode,
    };

    return order;
  }

  private shouldUpdate(
    existing: SubaccountOrder | null,
    payload: IndexerSubaccountOrder
  ): boolean {
    const existingDate =
      existing?.updatedAtMilliseconds ?? existing?.createdAtMilliseconds;
    const updatedAt = existingDate ? new Date(existingDate) : undefined;
    const incomingUpdatedAt = payload.updatedAt
      ? new Date(payload.updatedAt)
      : undefined;

    if (updatedAt) {
      if (incomingUpdatedAt) {
        if (updatedAt < incomingUpdatedAt) {
          return true;
        } else if (updatedAt > incomingUpdatedAt) {
          return false;
        }
      }
    } else if (incomingUpdatedAt) {
      return true;
    }

    const filled = existing?.totalFilled ?? 0;
    const incomingFilled = Number(payload.totalFilled);
    if (incomingFilled > filled) {
      return true;
    } else if (incomingFilled < filled) {
      return false;
    }

    // If the existing order is cancelling, we need to check if the incoming order is filled, canceled, or best effort canceled
    const finalStatuses = [
      IndexerOrderStatus.FILLED,
      IndexerOrderStatus.CANCELED,
      IndexerOrderStatus.BEST_EFFORT_CANCELED,
    ];

    if (existing?.status.value === OrderStatusEnum.CANCELLING) {
      return finalStatuses.includes(payload.status);
    }
    return existing?.status.isFinalized === false;
  }
}
