import {
  type IndexerSubaccountBatchUpdateMessage,
  type IndexerSubaccountSubscribedMessage,
} from "@klyra/shared";
import { type Store } from "../../core/store";
import { type Subaccount } from "../../types/accounts";
import { type BaseProcessor } from "../base.processor";
import { SubaccountProcessor } from "./subaccount.processor";
import { AccountBalancesProcessor } from "./account-balances.processor";

export class AccountProcessor implements BaseProcessor {
  private store: Store;

  private subaccountProcessor: SubaccountProcessor;
  private accountBalancesProcessor: AccountBalancesProcessor;

  constructor(store: Store) {
    this.store = store;
    this.subaccountProcessor = new SubaccountProcessor(store);
    this.accountBalancesProcessor = new AccountBalancesProcessor(store);
  }

  // WebSocket Methods
  public processSubscribed(msg: IndexerSubaccountSubscribedMessage): void {
    // TODO: update other fields besides subaccounts (orders, equity, free collateral, etc)
    const payload = msg.contents;
    const orders = payload.orders;
    const subaccounts = payload.subaccount.childSubaccounts;
    const newSubaccounts: Record<number, Subaccount> = {};

    for (const subaccount of subaccounts) {
      const newSubaccount = this.subaccountProcessor.process(
        subaccount,
        orders
      );

      if (typeof newSubaccount !== "undefined" && newSubaccount !== null) {
        newSubaccounts[newSubaccount.subaccountNumber] = newSubaccount;
      }
    }

    this.updateSubaccounts(newSubaccounts);
  }

  public processBatchUpdate(msg: IndexerSubaccountBatchUpdateMessage): void {
    const payload = msg.contents;
    const subaccountNumber = Number(msg.id?.split("/")[1]);
    if (typeof subaccountNumber === "undefined" || isNaN(subaccountNumber)) {
      return;
    }
    const existingSubaccounts = this.store.getState().user.account.subaccounts;
    const existingSubaccount = existingSubaccounts[subaccountNumber];
    const newSubaccount = this.subaccountProcessor.processUpdate(
      existingSubaccount,
      payload,
      subaccountNumber
    );
    if (newSubaccount) {
      this.updateSubaccount(newSubaccount);
    }
  }

  // REST Methods
  //   public processAccountBalances(msg: IndexerAccountBalancesMessage): void {}

  private updateSubaccount(subaccount: Subaccount): void {
    const existingSubaccounts = this.store.getState().user.account.subaccounts;
    const newSubaccounts = { ...existingSubaccounts };
    newSubaccounts[subaccount.subaccountNumber] = subaccount;

    this.updateSubaccounts(newSubaccounts);
  }

  private updateSubaccounts(subaccounts: Record<number, Subaccount>): void {
    const current = this.store.getState().user;
    const newUser = {
      ...current,
      account: {
        ...current.account,
        subaccounts,
      },
    };
    this.store.setState({ user: newUser });
  }
}
