import {
  IndexerPerpetualPositionStatus,
  type IndexerSubaccountPerpetualPositionBatch,
  type IndexerSubaccountPerpetualPositionSubscribed,
} from "@klyra/shared";
import { type Store } from "../../core/store";
import { MarginMode, type SubaccountPosition } from "../../types/accounts";
import { getAssetIdFromMarketId } from "../../utils/market-id";
import {
  convertIndexerPositionSide,
  getMarginModeFromSubaccount,
} from "../../utils/indexer-conversion";

export class PerpetualPositionsProcessor {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  public process(
    existing: Record<string, SubaccountPosition>,
    payload:
      | Record<string, IndexerSubaccountPerpetualPositionSubscribed>
      | undefined
  ): Record<string, SubaccountPosition> {
    if (!payload) return existing;

    const result: Record<string, SubaccountPosition> = {};

    for (const [market, value] of Object.entries(payload)) {
      const existingPosition = existing[market] ?? ({} as SubaccountPosition);
      const newPosition = this.processPerpetualPosition(
        existingPosition,
        value
      );
      if (newPosition) {
        result[market] = newPosition;
      } else {
        // delete the key
        const { [market]: _, ...rest } = result;
        return rest;
      }
    }

    return result !== existing ? result : existing;
  }

  public processChanges(
    existing: Record<string, SubaccountPosition>,
    payload: IndexerSubaccountPerpetualPositionBatch[] | undefined
  ): Record<string, SubaccountPosition> {
    if (!payload) return existing;

    const result: Record<string, SubaccountPosition> = existing;

    for (const item of payload) {
      if (item.market) {
        const newPosition = this.processPerpetualPosition(
          existing[item.market] ?? ({} as SubaccountPosition),
          // TODO: find a better way to convert the payload (or don't convert at all and improve the processPerpetualPosition method)
          this.convertPerpetualPosition(item)
        );
        if (newPosition) {
          result[item.market] = newPosition;
        } else {
          // delete the key
          const { [item.market]: _, ...rest } = result;
          return rest;
        }
      }
    }

    return result !== existing ? result : existing;
  }

  private processPerpetualPosition(
    existing: SubaccountPosition,
    payload: IndexerSubaccountPerpetualPositionSubscribed
  ): SubaccountPosition | null {
    if (payload.status === IndexerPerpetualPositionStatus.CLOSED) {
      return null;
    }

    const modified = { ...existing };

    const marketId = payload.market;
    const status = payload.status as IndexerPerpetualPositionStatus;
    const entryPrice = Number(payload.entryPrice);
    const size = Number(payload.size);

    const isOpen = status === IndexerPerpetualPositionStatus.OPEN;

    if (size && payload.status in IndexerPerpetualPositionStatus) {
      const realizedPnl = Number(payload.realizedPnl);
      if (typeof realizedPnl === "number") {
        if (isOpen) {
          // if the position is not closed, we need to calculate the realized PNL percent
          if (entryPrice) {
            const positionEntryValue = Math.abs(entryPrice * size);
            const realizedPnlPercent = Math.abs(
              realizedPnl / positionEntryValue
            );
            modified.realizedPnlPercent =
              realizedPnlPercent > 0 ? realizedPnlPercent : null;
          }
        } else {
          modified.realizedPnlPercent = null;
        }
      } else {
        modified.realizedPnlPercent = null;
      }
    }

    const storeMarket = this.store.getState().markets[marketId];
    const marketSpotPrice = storeMarket?.spotPrice;

    if (marketSpotPrice) {
      if (isOpen) {
        const valueTotal = marketSpotPrice * size;
        const notional = Math.abs(valueTotal);
        const adjustedImf =
          storeMarket.configs.effectiveInitialMarginFraction || 0;
        const adjustedMmf = storeMarket.configs.maintenanceMarginFraction || 0;
        const maxLeverage = adjustedImf !== 0 ? 1 / adjustedImf : null;
        const initialRiskTotal = notional * adjustedImf;

        if (entryPrice) {
          const entryValue = size * entryPrice;
          const currentValue = size * marketSpotPrice;
          const unrealizedPnl = currentValue - entryValue;
          const unrealizedPnlPercent =
            entryValue !== 0 ? unrealizedPnl / Math.abs(entryValue) : null;

          modified.unrealizedPnl = unrealizedPnl;
          modified.unrealizedPnlPercent = unrealizedPnlPercent;
        }

        const marginMode =
          existing.marginMode ??
          getMarginModeFromSubaccount(payload.subaccountNumber);

        let marginValue = null;
        if (marginMode === MarginMode.CROSS) {
          const maintenanceMargin =
            storeMarket.configs.maintenanceMarginFraction || 0;
          marginValue = maintenanceMargin * notional;
          modified.marginValue = marginValue;
        } else {
          const subaccount =
            this.store.getState().user.account.subaccounts[
              payload.subaccountNumber
            ];
          const equity = Number(subaccount?.equity);
          marginValue = equity;
        }

        modified.valueTotal = valueTotal;
        modified.notionalTotal = notional;
        modified.adjustedImf = adjustedImf;
        modified.adjustedMmf = adjustedMmf;
        modified.initialRiskTotal = initialRiskTotal;
        modified.maxLeverage = maxLeverage;
        modified.marginValue = marginValue;
      } else {
        modified.valueTotal = null;
        modified.notionalTotal = null;
        modified.adjustedImf = null;
        modified.adjustedMmf = null;
        modified.initialRiskTotal = null;
        modified.maxLeverage = null;
        modified.unrealizedPnl = null;
        modified.unrealizedPnlPercent = null;
        modified.marginValue = null;
      }
    } else {
      modified.realizedPnlPercent = null;
      modified.unrealizedPnl = null;
      modified.unrealizedPnlPercent = null;
      modified.valueTotal = null;
      modified.notionalTotal = null;
      modified.adjustedImf = null;
      modified.adjustedMmf = null;
      modified.initialRiskTotal = null;
      modified.maxLeverage = null;
      modified.marginValue = null;
    }

    const side = convertIndexerPositionSide(payload.side);
    const assetId = getAssetIdFromMarketId(marketId);
    const transformed: SubaccountPosition = {
      ...existing,
      ...modified,
      id: payload.market,
      assetId: assetId ?? "",
      size: Number(payload.size),
      side,
      entryPrice,
      createdAtMilliseconds: payload.createdAt
        ? new Date(payload.createdAt).getTime()
        : undefined,
      exitPrice: payload.exitPrice ? Number(payload.exitPrice) : undefined,
    };

    return transformed;
  }

  private convertPerpetualPosition(
    payload: IndexerSubaccountPerpetualPositionBatch
  ): IndexerSubaccountPerpetualPositionSubscribed {
    return {
      ...payload,
      createdAt: "",
      createdAtHeight: "",
    } as IndexerSubaccountPerpetualPositionSubscribed;
  }
}
