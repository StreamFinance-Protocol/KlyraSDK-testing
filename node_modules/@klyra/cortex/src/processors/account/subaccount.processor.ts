import {
  type IndexerSubaccountBatchUpdateMessageContents,
  type IndexerSubaccountOrder,
  type IndexerSubaccountResponse,
} from "@klyra/shared";
import { type Store } from "../../core/store";
import { type Subaccount } from "../../types/accounts";
import { AssetPositionsProcessor } from "./asset-positions.processor";
import { PerpetualPositionsProcessor } from "./perpetual-positions.processor";
import { FundingPaymentsProcessor } from "./funding-payments.processor";
import { HistoricalPnlsProcessor } from "./historical-pnls.processor";
import { TransfersProcessor } from "./transfers.processor";
import { OrdersProcessor } from "./orders.processor";
import { FillsProcessor } from "./fills.processor";

export class SubaccountProcessor {
  private store: Store;

  private assetPositionsProcessor: AssetPositionsProcessor;
  private perpetualPositionsProcessor: PerpetualPositionsProcessor;
  private fundingPaymentsProcessor: FundingPaymentsProcessor;
  private historicalPnlsProcessor: HistoricalPnlsProcessor;
  private transfersProcessor: TransfersProcessor;
  private ordersProcessor: OrdersProcessor;
  private fillsProcessor: FillsProcessor;

  constructor(store: Store) {
    this.store = store;
    this.assetPositionsProcessor = new AssetPositionsProcessor(store);
    this.perpetualPositionsProcessor = new PerpetualPositionsProcessor(store);
    this.fundingPaymentsProcessor = new FundingPaymentsProcessor(store);
    this.historicalPnlsProcessor = new HistoricalPnlsProcessor(store);
    this.transfersProcessor = new TransfersProcessor(store);
    this.ordersProcessor = new OrdersProcessor(store);
    this.fillsProcessor = new FillsProcessor(store);
  }

  public process(
    msg: IndexerSubaccountResponse,
    orders: IndexerSubaccountOrder[]
  ): Subaccount | null {
    const existingUser = this.store.getState().user;

    const subaccountNumber = Number(msg.subaccountNumber);
    const existingSubaccount =
      existingUser.account.subaccounts[subaccountNumber];
    const newSubaccount = this.processSubaccount(
      existingSubaccount,
      msg,
      orders,
      true
    );
    return newSubaccount;
  }

  public processUpdate(
    existingSubaccount: Subaccount | undefined,
    msg: IndexerSubaccountBatchUpdateMessageContents,
    subaccountNumber: number
  ): Subaccount | null {
    const modified = existingSubaccount ?? ({} as Subaccount);

    for (const item of msg) {
      if (item.assetPositions) {
        const assetPositions = this.assetPositionsProcessor.process(
          item.assetPositions
        );
        if (assetPositions && assetPositions.length > 0) {
          modified.assetPositions = assetPositions;
        }
      }
      if (item.perpetualPositions) {
        const perpetualPositions =
          this.perpetualPositionsProcessor.processChanges(
            existingSubaccount?.positions ?? {},
            item.perpetualPositions
          );
        if (typeof perpetualPositions !== "undefined") {
          modified.positions = perpetualPositions;
          modified.openPositions = perpetualPositions;
        }
      }
      if (item.orders) {
        const orders = this.ordersProcessor.process(
          existingSubaccount?.orders ?? [],
          item.orders,
          subaccountNumber
        );
        if (orders.length > 0) {
          modified.orders = orders;
        }
      }
      if (item.fills) {
        const fills = this.fillsProcessor.process(
          existingSubaccount?.fills ?? [],
          item.fills,
          subaccountNumber
        );
        if (fills.length > 0) {
          modified.fills = fills;
        }
      }
      if (item.transfers) {
        const transfers = this.transfersProcessor.process(
          existingSubaccount?.transfers ?? [],
          item.transfers
        );
        if (transfers.length > 0) {
          modified.transfers = transfers;
        }
      }
    }

    return modified;
  }

  private processSubaccount(
    existing: Subaccount | undefined,
    payload: IndexerSubaccountResponse | undefined,
    orders: IndexerSubaccountOrder[],
    firstTime: boolean
  ): Subaccount | null {
    if (!payload) {
      return existing ?? null;
    }

    const modified = existing ?? ({} as Subaccount);
    const subaccountNumber = payload.subaccountNumber
      ? Number(payload.subaccountNumber)
      : 0;
    modified.subaccountNumber = subaccountNumber;
    modified.address = payload.address;
    modified.equity = Number(payload.equity);
    modified.freeCollateral = Number(payload.freeCollateral);
    modified.marginEnabled = payload.marginEnabled;

    if (firstTime) {
      const perpetualPositions = existing?.positions ?? {};
      const newPerpetualPositions = this.perpetualPositionsProcessor.process(
        perpetualPositions,
        payload.openPerpetualPositions
      );
      modified.positions = newPerpetualPositions;
      modified.openPositions = newPerpetualPositions;
    }

    if (orders.length > 0) {
      const newOrders = this.ordersProcessor.process(
        existing?.orders ?? [],
        orders,
        subaccountNumber
      );
      modified.orders = newOrders;
    }

    if (Object.values(payload.assetPositions).length > 0) {
      const assetPositions = this.assetPositionsProcessor.process(
        Object.values(payload.assetPositions)
      );
      if (assetPositions && assetPositions.length > 0) {
        modified.assetPositions = assetPositions;
      }
    }

    return modified;
  }
}
