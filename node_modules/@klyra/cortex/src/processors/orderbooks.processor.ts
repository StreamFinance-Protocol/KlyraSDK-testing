import {
  type IndexerOrderbookBatchUpdateMessage,
  type IndexerOrderbookSubscribedMessage,
} from "@klyra/shared";
import { type Store } from "../core/store";
import { type MarketOrderbook, type OrderbookLine } from "../types/markets";
import { type BaseProcessor } from "./base.processor";

interface OrderbookEntry {
  size: number;
  price: number;
  offset?: number;
}

export class OrderbooksProcessor implements BaseProcessor {
  private store: Store;

  constructor(store: Store) {
    this.store = store;
  }

  public processSubscribed(msg: IndexerOrderbookSubscribedMessage): void {
    const marketId = msg.id!;

    // asks are by default sorted from lowest to highest
    const asks = msg.contents.asks?.map((ask) => this.processEntry(ask));
    // bids are by default sorted from highest to lowest
    const bids = msg.contents.bids?.map((bid) => this.processEntry(bid));

    const consolidated = this.consolidate(asks, bids);
    if (consolidated) {
      const orderbooks = this.store.getState().orderbooks;
      this.store.setState({
        orderbooks: {
          ...orderbooks,
          [marketId]: consolidated,
        },
      });
    }
  }

  // TODO: review this method
  public processBatchUpdate(msg: IndexerOrderbookBatchUpdateMessage): void {
    const marketId = msg.id!;
    const orderbooks = this.store.getState().orderbooks;
    const orderbook = orderbooks[marketId];
    if (!orderbook) return;

    let existingOrderbook: MarketOrderbook = {
      ...orderbook,
    };

    for (const change of msg.contents) {
      const updatedAsks = this.updateOrderbookSide(
        existingOrderbook,
        "asks",
        change.asks ?? [],
        true
      );
      const updatedBids = this.updateOrderbookSide(
        existingOrderbook,
        "bids",
        change.bids ?? [],
        false
      );
      const newOrderbook = this.calculate(updatedAsks, updatedBids);
      if (newOrderbook) {
        existingOrderbook = newOrderbook;
      }
    }

    this.store.setState({
      orderbooks: {
        ...orderbooks,
        [marketId]: existingOrderbook,
      },
    });
  }

  private processEntry(entry: { size: string; price: string }): OrderbookEntry {
    return {
      size: Number(entry.size),
      price: Number(entry.price),
    };
  }

  /**
   * Consolidates the orderbook by removing crossed orders and recalculates orderbook metrics.
   *
   * @param asks - The existing market orderbook asks.
   * @param bids - The existing market orderbook bids.
   * @returns The consolidated MarketOrderbook with updated metrics or null if consolidation fails.
   */
  private consolidate(
    asks: OrderbookEntry[] | undefined,
    bids: OrderbookEntry[] | undefined
  ): MarketOrderbook | null {
    const newAsks: OrderbookEntry[] = asks ?? [];
    const newBids: OrderbookEntry[] = bids ?? [];

    // Ensure both asks and bids are present
    if (newAsks.length === 0 || newBids.length === 0) {
      return null;
    }

    const askIndex = 0;
    const bidIndex = 0;

    // Iterate through asks and bids to remove crossed orders
    while (askIndex < newAsks.length && bidIndex < newBids.length) {
      const ask = newAsks[askIndex]!;
      const bid = newBids[bidIndex]!;

      // Check if the current ask crosses with the current bid
      if (ask.price <= bid.price) {
        // Determine which order to remove based on offset and size
        const askOffset = ask.offset ?? 0;
        const bidOffset = bid.offset ?? 0;

        if (askOffset === bidOffset) {
          if (ask.size >= bid.size) {
            newBids.splice(bidIndex, 1);
          } else {
            newAsks.splice(askIndex, 1);
          }
        } else if (askOffset > bidOffset) {
          newBids.splice(bidIndex, 1);
        } else {
          newAsks.splice(askIndex, 1);
        }
      } else {
        // No crossing, move to the next ask or bid
        break;
      }
    }

    // Recalculate the orderbook metrics after consolidation
    const consolidatedOrderbook = this.calculate(newAsks, newBids);
    return consolidatedOrderbook;
  }

  private calculate(
    asks?: OrderbookEntry[],
    bids?: OrderbookEntry[]
  ): MarketOrderbook | null {
    if (!asks || !bids || asks.length === 0 || bids.length === 0) {
      return null;
    }

    let asksDepth = 0;
    const modifiedAsks: OrderbookLine[] = asks.map((ask) => {
      const { size, price } = ask;
      asksDepth += size;
      const depth = asksDepth;
      const sizeCost = size * price;
      const orderbookEntry: OrderbookLine = {
        ...ask,
        depth,
        sizeCost,
        // TODO: calculate offset or see if we need to calculate it at all
        offset: 0,
      };
      return orderbookEntry;
    });

    let bidsDepth = 0;
    const modifiedBids: OrderbookLine[] = bids.map((bid) => {
      const { size, price } = bid;
      bidsDepth += size;
      const depth = bidsDepth;
      const sizeCost = size * price;
      const orderbookEntry: OrderbookLine = {
        ...bid,
        depth,
        sizeCost,
        // TODO: calculate offset or see if we need to calculate it at all
        offset: 0,
      };
      return orderbookEntry;
    });

    const firstAskPrice = modifiedAsks[0]?.price;
    const firstBidPrice = modifiedBids[0]?.price;

    const orderbook: MarketOrderbook = {
      asks: modifiedAsks,
      bids: modifiedBids,
      midPrice: null,
      spreadPercent: null,
      spread: null,
    };

    if (firstAskPrice && firstBidPrice) {
      orderbook.midPrice = (firstAskPrice + firstBidPrice) / 2;
      const spread = firstAskPrice - firstBidPrice;
      orderbook.spread = spread;
      orderbook.spreadPercent = spread / orderbook.midPrice;
    }

    return orderbook;
  }

  private updateOrderbookSide(
    existingOrderbook: MarketOrderbook,
    side: "asks" | "bids",
    changes: [string, string][],
    isAscending: boolean
  ): OrderbookLine[] {
    const comparator = (a: OrderbookLine, b: OrderbookLine): number =>
      isAscending ? a.price - b.price : b.price - a.price;

    const updatedSide = [...existingOrderbook[side]];

    for (const [price, size] of changes) {
      const newSize = parseFloat(size);
      const newPrice = parseFloat(price);

      if (isNaN(newSize) || isNaN(newPrice)) continue;

      const index = updatedSide.findIndex((entry) => entry.price === newPrice);
      if (index !== -1) {
        if (newSize === 0) {
          updatedSide.splice(index, 1);
        } else {
          updatedSide[index] = {
            ...updatedSide[index],
            size: newSize,
            price: newPrice,
            sizeCost: newSize * newPrice,
            offset: 0,
            depth: 0,
          };
        }
      } else if (newSize !== 0) {
        const newEntry: OrderbookLine = {
          size: newSize,
          price: newPrice,
          depth: 0,
          sizeCost: newSize * newPrice,
          offset: 0, // TODO: Implement offset calculation if needed
        };
        updatedSide.push(newEntry);
        updatedSide.sort(comparator);
      }
    }

    // Recalculate depth
    let cumulativeDepth = 0;
    return updatedSide.map((entry) => {
      cumulativeDepth += entry.size;
      return { ...entry, depth: cumulativeDepth };
    });
  }
}
