export function merge<T>(source: T, target: object): T {
  return { ...source, ...target };
}

type Type = "string" | "number" | "boolean" | "datetime";

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- We use any to allow for any type of value
type Any = any;

export function transform<T extends object>(
  existing: T | undefined,
  input: Record<string, Any> | undefined,
  keymap: Partial<Record<Type, Record<string, keyof T>>>
): T {
  const output: T = existing ? { ...existing } : ({} as T);

  if (input) {
    for (const [type, map] of Object.entries(keymap)) {
      for (const [key, target] of Object.entries(map)) {
        const value = getValue(input, key, type);
        if (value !== undefined) {
          output[target] = value as T[typeof target];
        }
      }
    }
  }

  return output;
}

function getValue(
  input: Record<string, Any>,
  key: string,
  type: string
): unknown {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- We use any to allow for any type of value
  const value = input[key];
  if (value === undefined) return undefined;

  switch (type) {
    case "number":
      return Number(value);
    case "string":
      return String(value);
    case "boolean":
      return Boolean(value);
    case "datetime":
      return new Date(String(value)).getTime();
    default:
      return value;
  }
}
