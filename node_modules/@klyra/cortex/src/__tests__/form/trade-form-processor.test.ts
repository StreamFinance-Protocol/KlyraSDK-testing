import { describe, expect, test, beforeAll, beforeEach } from "@jest/globals";
import {
  type IndexerOrderbookSubscribedMessage,
  OrderExecution,
  OrderSide,
  OrderTimeInForce,
} from "@klyra/shared";
import { Store } from "../../core/store";
import { TradeFormProcessor } from "../../processors/forms/trade/trade-form.processor";
import { MarginMode } from "../../types/accounts";
import { AccountProcessor } from "../../processors/account/account.processor";
import { MarketsProcessor } from "../../processors/markets.processor";
import { TradeFormType, type LimitTradeFormInputs } from "../../types/forms";
import { OrderbooksProcessor } from "../../processors/orderbooks.processor";
import { AccountsMocks, MarketsMocks } from "../mocks";

const ORDERBOOK_SUBSCRIBED_MESSAGE = {
  type: "subscribed",
  connection_id: "54480a41-95fe-4253-9b39-44a465690af2",
  message_id: 4,
  channel: "v4_orderbook",
  id: "BTC-USD",
  contents: {
    bids: [
      { price: "62613.6", size: "0.415" },
      { price: "62612.1", size: "0.415" },
      { price: "62606.6", size: "7.673" },
      { price: "62606.5", size: "15.346" },
      { price: "62606.4", size: "46.038" },
      { price: "62606", size: "2.301" },
      { price: "62605.9", size: "0.768" },
      { price: "62605.8", size: "99.775" },
      { price: "62605.7", size: "0.768" },
      { price: "62605.6", size: "8.444" },
    ],
    asks: [
      { price: "62629.9", size: "0.415" },
      { price: "62633.6", size: "0.415" },
      { price: "62637.9", size: "0.758" },
      { price: "62638.7", size: "0.758" },
      { price: "62638.8", size: "0.758" },
      { price: "62638.9", size: "0.758" },
      { price: "62639.1", size: "1.516" },
      { price: "62639.5", size: "3.032" },
      { price: "62639.7", size: "2.274" },
      { price: "62639.8", size: "0.758" },
    ],
  },
} as unknown as IndexerOrderbookSubscribedMessage;

describe("TradesProcessor", () => {
  let store: Store;
  let tradeFormProcessor: TradeFormProcessor;
  let accountProcessor: AccountProcessor;
  let orderbookProcessor: OrderbooksProcessor;

  beforeAll(() => {
    store = new Store();
    tradeFormProcessor = new TradeFormProcessor(store);
    accountProcessor = new AccountProcessor(store);
    orderbookProcessor = new OrderbooksProcessor(store);
    // set market prices
    const marketsProcessor = new MarketsProcessor(store);
    marketsProcessor.processSubscribed(MarketsMocks.SUBSCRIBED_MESSAGE);
    accountProcessor.processSubscribed(AccountsMocks.SUBSCRIBED_MESSAGE);
    orderbookProcessor.processSubscribed(ORDERBOOK_SUBSCRIBED_MESSAGE);
  });

  beforeEach(() => {
    tradeFormProcessor.resetForm();

    tradeFormProcessor.processInput("marketId", "BTC-USD");
    tradeFormProcessor.processInput("marginMode", MarginMode.CROSS);
  });

  test("should be defined", () => {
    expect(TradeFormProcessor).toBeDefined();
  });

  test("should handle schema validation errors", () => {
    tradeFormProcessor.processInput("quoteSize", null);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(1);
  });

  test("should update the form state", () => {
    tradeFormProcessor.processInput("quoteSize", 1);
    tradeFormProcessor.processInput("price", 0.1);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);

    const inputs = formState.inputs as LimitTradeFormInputs;
    expect(inputs.price).toBe(0.1);
    expect(inputs.quoteSize).toBe(1);
  });

  test("should calculate the quote size", () => {
    tradeFormProcessor.processInput("baseSize", 0.1);
    tradeFormProcessor.processInput("price", 0.1);

    const formState = store.getState().forms.trade;
    const inputs = formState.inputs as LimitTradeFormInputs;
    expect(inputs.quoteSize).toBe(1);
  });

  test("should generate a summary for a sell order", () => {
    tradeFormProcessor.processInput("quoteSize", 1);
    tradeFormProcessor.processInput("price", 0.1);
    tradeFormProcessor.processInput("side", OrderSide.SELL);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);

    const { summary } = formState;
    expect(summary).not.toBeNull();
    expect(summary?.price).toBe(0.1);
    expect(summary?.total).toBe(-0.1);
    expect(summary?.baseSize).toBe(0.1);
  });

  test("should generate a summary for a buy order", () => {
    tradeFormProcessor.processInput("quoteSize", 1);
    tradeFormProcessor.processInput("price", 0.1);
    tradeFormProcessor.processInput("side", OrderSide.BUY);
    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);

    const { summary } = formState;
    expect(summary).not.toBeNull();
    expect(summary?.price).toBe(0.1);
    expect(summary?.total).toBe(0.1);
    expect(summary?.baseSize).toBe(0.1);
  });

  // TODO: add tests for the other trade types (market, stop-limit, take-profit-limit, stop-market, take-profit-market)
  test("should calculate the price for a buy market order", () => {
    tradeFormProcessor.processInput("type", TradeFormType.MARKET);
    tradeFormProcessor.processInput("side", OrderSide.BUY);
    tradeFormProcessor.processInput("baseSize", 100);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);
    const { summary } = formState;
    expect(summary).not.toBeNull();

    // since the market order is buying, it should take the first ask price
    const firstAsk = store.getState().orderbooks["BTC-USD"]?.asks[0];
    expect(summary?.price).toBe(firstAsk?.price);
    expect(summary?.total).toBe(100);
    // TODO: when we add custom slippage, we need to update this to check against the payloadPrice
    const slippage = 0.01;
    expect(summary?.payloadPrice).toBe((summary?.price ?? 0) * (1 + slippage));
  });

  test("should calculate the price for a sell market order", () => {
    tradeFormProcessor.processInput("type", TradeFormType.MARKET);
    tradeFormProcessor.processInput("side", OrderSide.SELL);
    tradeFormProcessor.processInput("baseSize", 100);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);
    const { summary } = formState;
    expect(summary).not.toBeNull();

    // since the market order is selling, it should take the first ask price
    const firstBid = store.getState().orderbooks["BTC-USD"]?.bids[0];
    expect(summary?.price).toBe(firstBid?.price);
    expect(summary?.total).toBe(-100);
    // TODO: when we add custom slippage, we need to update this to check against the payloadPrice
    const slippage = 0.01;
    expect(summary?.payloadPrice).toBe((summary?.price ?? 0) * (1 - slippage));
  });

  test("should calculate the options for a market order", () => {
    tradeFormProcessor.processInput("type", TradeFormType.MARKET);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);

    const options = formState.options;
    expect(options?.needsReduceOnly).toBe(true);
    expect(options?.needsExecution).toBe(true);
    expect(options?.executionOptions).toEqual([OrderExecution.IOC]);
    expect(options?.needsGoodTilTime).toBe(true);
    expect(options?.needsPrice).toBe(false);
    expect(options?.needsTriggerPrice).toBe(false);
  });

  test("should calculate the options for a Take Profit market order", () => {
    tradeFormProcessor.processInput("type", TradeFormType.TAKE_PROFIT_MARKET);

    const formState = store.getState().forms.trade;

    const options = formState.options;
    expect(options?.needsReduceOnly).toBe(true);
    expect(options?.needsExecution).toBe(true);
    expect(options?.executionOptions).toEqual([OrderExecution.IOC]);
    expect(options?.needsGoodTilTime).toBe(true);
    expect(options?.needsPrice).toBe(false);
    expect(options?.needsTriggerPrice).toBe(true);
  });

  test("should calculate the options for a limit order with GTT", () => {
    tradeFormProcessor.processInput("type", TradeFormType.LIMIT);
    tradeFormProcessor.processInput("side", OrderSide.SELL);
    tradeFormProcessor.processInput("baseSize", 100);
    tradeFormProcessor.processInput("timeInForce", OrderTimeInForce.GTT);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);

    const options = formState.options;
    expect(options?.needsPrice).toBe(true);
    expect(options?.needsTimeInForce).toBe(true);
    expect(options?.needsGoodTilTime).toBe(true);
    expect(options?.needsPostOnly).toBe(true);
    expect(options?.needsReduceOnly).toBe(false);
    expect(options?.needsTriggerPrice).toBe(false);
  });

  test("should calculate the options for a limit order with IOC", () => {
    tradeFormProcessor.processInput("type", TradeFormType.LIMIT);
    tradeFormProcessor.processInput("side", OrderSide.SELL);
    tradeFormProcessor.processInput("baseSize", 100);
    tradeFormProcessor.processInput("timeInForce", OrderTimeInForce.IOC);

    const formState = store.getState().forms.trade;
    expect(Object.keys(formState.errors ?? {}).length).toBe(0);

    const options = formState.options;
    expect(options?.needsPrice).toBe(true);
    expect(options?.needsTimeInForce).toBe(true);
    expect(options?.needsGoodTilTime).toBe(false);
    expect(options?.needsPostOnly).toBe(false);
    expect(options?.needsReduceOnly).toBe(true);
    expect(options?.needsTriggerPrice).toBe(false);
  });

  test("should calculate the options for a Take Profit limit order with default execution", () => {
    tradeFormProcessor.processInput("type", TradeFormType.TAKE_PROFIT_LIMIT);
    tradeFormProcessor.processInput("execution", OrderExecution.DEFAULT);

    const formState = store.getState().forms.trade;

    const options = formState.options;
    expect(options?.needsReduceOnly).toBe(false);
    expect(options?.needsExecution).toBe(true);
    expect(options?.executionOptions).toEqual([
      OrderExecution.DEFAULT,
      OrderExecution.IOC,
      OrderExecution.POST_ONLY,
    ]);
    expect(options?.needsGoodTilTime).toBe(true);
    expect(options?.needsPrice).toBe(true);
    expect(options?.needsTriggerPrice).toBe(true);
  });

  test("should calculate the options for a Take Profit limit order with IOC", () => {
    tradeFormProcessor.processInput("type", TradeFormType.TAKE_PROFIT_LIMIT);
    tradeFormProcessor.processInput("execution", OrderExecution.IOC);

    const formState = store.getState().forms.trade;

    const options = formState.options;
    expect(options?.needsReduceOnly).toBe(true);
    expect(options?.needsExecution).toBe(true);
    expect(options?.executionOptions).toEqual([
      OrderExecution.DEFAULT,
      OrderExecution.IOC,
      OrderExecution.POST_ONLY,
    ]);
    expect(options?.needsGoodTilTime).toBe(true);
    expect(options?.needsPrice).toBe(true);
    expect(options?.needsTriggerPrice).toBe(true);
  });

  // test("should calculate the price for a sell market order that takes more than one order from the orderbook", () => {
  //   tradeFormProcessor.processInput("type", TradeFormType.MARKET);
  //   tradeFormProcessor.processInput("side", OrderSide.SELL);
  //   tradeFormProcessor.processInput("quoteSize", 1000);

  //   const formState = store.getState().forms["trade"];
  //   expect(Object.keys(formState.errors ??{}).length).toBe(0);
  //   const { summary } = formState;
  //   expect(summary).not.toBeNull();

  //   // since the market order is selling, it should take the first ask price
  //   const firstBid = store.getState().orderbooks["BTC-USD"].bids[0];
  //   expect(summary?.price).toBe(firstBid.price);
  //   expect(summary?.total).toBe(-100);
  //   // TODO: when we add custom slippage, we need to update this to check against the payloadPrice
  //   const slippage = 0.01;
  //   expect(summary?.payloadPrice).toBe(summary?.price * (1 - slippage));
  // });
});
