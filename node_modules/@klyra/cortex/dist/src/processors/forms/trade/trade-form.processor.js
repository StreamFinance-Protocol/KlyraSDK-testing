"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradeFormProcessor = void 0;
const shared_1 = require("@klyra/shared");
const shared_2 = require("@klyra/shared");
const trade_forms_1 = require("../../../schemas/trade-forms");
const forms_1 = require("../../../types/forms");
const rounder_1 = require("../../../utils/rounder");
const orderbook_1 = require("../../../utils/orderbook");
const base_form_processor_1 = require("../base-form.processor");
const values_1 = require("./values");
const trade_form_summary_calculator_1 = require("./trade-form-summary.calculator");
const trade_form_options_calculator_1 = require("./trade-form-options.calculator");
class TradeFormProcessor extends base_form_processor_1.BaseFormProcessor {
    constructor(store) {
        super(store, forms_1.FormType.TRADE);
        this.optionsProcessor = new trade_form_options_calculator_1.TradeFormOptionsCalculator(store);
        this.summaryProcessor = new trade_form_summary_calculator_1.TradeFormSummaryCalculator(store);
    }
    resetForm() {
        this.updateForm(values_1.DEFAULT_TRADE_FORM_STATE);
    }
    processInput(fieldName, value) {
        const { inputs } = this.getCurrentFormState();
        const { subaccountNumber, account } = this.store.getState().user;
        const subaccount = account.subaccounts[subaccountNumber];
        if (!subaccount) {
            throw new Error(`Subaccount number ${subaccountNumber} not found.`);
        }
        // create an internal copy of the inputs state so we can manipulate it without side effects
        const newInputs = { ...inputs, [fieldName]: value };
        this.updateForm({ inputs: newInputs });
        // validate the inputs
        const newOptions = this.optionsProcessor.calculate(newInputs);
        this.updateForm({ options: newOptions });
        const validationResult = this.validateInputs(newInputs);
        // if the inputs are invalid, set the errors in the store and return
        if (!validationResult.isValid) {
            // TODO: better error schema
            const errors = validationResult.errors.reduce((acc, error) => {
                if ("field" in error && "error" in error) {
                    acc[error.field] = error.error;
                }
                return acc;
            }, {});
            if (Object.keys(errors).length > 0) {
                this.updateForm({ errors });
                return;
            }
        }
        const calculationResult = this.calculateFormResult(newInputs, fieldName, subaccount);
        if (!calculationResult)
            return;
        const summary = this.summaryProcessor.calculate(calculationResult, subaccount);
        if (!summary)
            return;
        this.updateForm({
            inputs: calculationResult,
            postResults: {},
            summary,
        });
    }
    validateInputs(inputs) {
        const errors = [];
        // validate agains the schema using zod
        const validationResult = (0, trade_forms_1.validateTradeForm)(inputs);
        if (!validationResult.success) {
            errors.push({ field: "inputs", error: validationResult.error.message });
        }
        // TODO: make other validations
        return { isValid: errors.length === 0, errors };
    }
    calculateFormResult(newInputs, fieldName, subaccount) {
        const isBuying = newInputs.side !== shared_1.OrderSide.SELL;
        switch (newInputs.type) {
            case forms_1.TradeFormType.MARKET:
            case forms_1.TradeFormType.STOP_MARKET:
            case forms_1.TradeFormType.TAKE_PROFIT_MARKET:
                return this.calculateMarketOrder(newInputs, fieldName, subaccount, isBuying);
            case forms_1.TradeFormType.LIMIT:
            case forms_1.TradeFormType.STOP_LIMIT:
            case forms_1.TradeFormType.TAKE_PROFIT_LIMIT:
                return this.calculateLimitOrder(newInputs, fieldName, subaccount, isBuying);
            default:
                return null;
        }
    }
    calculateMarketOrder(newInputs, fieldName, subaccount, isBuying) {
        var _a, _b;
        const { marketId, baseSize, quoteSize } = newInputs;
        const storeState = this.store.getState();
        const newMarketOrder = { ...newInputs };
        const market = storeState.markets[marketId];
        if (!market)
            throw new Error(`Market ${marketId} not found.`);
        let marketOrder = null;
        if (fieldName === "baseSize") {
            marketOrder = this.calculateMarketOrderFromBaseSize(baseSize, market, isBuying);
        }
        else if (fieldName === "quoteSize") {
            marketOrder = this.calculateMarketOrderFromQuoteSize(quoteSize, market, isBuying);
        }
        else if (fieldName === "leverage") {
            const leverage = (_a = newInputs.leverage) !== null && _a !== void 0 ? _a : 0;
            marketOrder = this.calculateMarketOrderFromLeverage(leverage, market, subaccount);
        }
        if (marketOrder) {
            newMarketOrder.baseSize = marketOrder.baseSizeTotal;
            newMarketOrder.quoteSize = marketOrder.quoteSizeTotal;
            const internal = { ...newMarketOrder.internal };
            internal.filled = marketOrder.filled;
            internal.worstPrice = (_b = marketOrder.worstPrice) !== null && _b !== void 0 ? _b : undefined;
            newMarketOrder.internal = internal;
        }
        if (newMarketOrder.baseSize && newMarketOrder.quoteSize) {
            newMarketOrder.internal = {
                ...newMarketOrder.internal,
                price: newMarketOrder.baseSize / newMarketOrder.quoteSize,
            };
        }
        return newMarketOrder;
    }
    calculateMarketOrderFromLeverage(leverage, market, subaccount) {
        var _a, _b, _c;
        const stepSize = market.configs.stepSize;
        const equity = subaccount.equity;
        const spotPrice = market.spotPrice;
        // TODO: get user fee rate --- const feeRate = user.takerFeeRate;
        const positions = subaccount.openPositions;
        const positionSize = (_a = positions === null || positions === void 0 ? void 0 : positions[market.id]) === null || _a === void 0 ? void 0 : _a.size;
        if (!equity || !spotPrice || !positionSize || equity <= 0)
            return null;
        const existingLeverage = (positionSize * spotPrice) / equity;
        let isBuying = null;
        if (leverage > existingLeverage) {
            isBuying = true;
        }
        else if (existingLeverage > leverage) {
            isBuying = false;
        }
        if (isBuying === null)
            return null;
        const orderbookField = isBuying ? "asks" : "bids";
        const orderbook = (0, orderbook_1.getOrderbookFromStore)(this.store, market.market)[orderbookField];
        let quoteSizeTotal = 0;
        let baseSizeTotal = 0;
        let worstPrice = null;
        let filled = false;
        const marketOrderOrderBook = [];
        const orderbookFirstOrNull = (_b = orderbook[0]) !== null && _b !== void 0 ? _b : null;
        const currentPositionValue = positionSize * ((_c = orderbookFirstOrNull === null || orderbookFirstOrNull === void 0 ? void 0 : orderbookFirstOrNull.price) !== null && _c !== void 0 ? _c : 0) || 0;
        const targetPositionValue = leverage * equity;
        let remainingOrderSize = targetPositionValue - currentPositionValue;
        if ((isBuying && remainingOrderSize < 0) ||
            (!isBuying && remainingOrderSize > 0)) {
            // The order would decrease leverage, which is not what we want for a "leverage" input
            return null;
        }
        for (const entry of orderbook) {
            const { price, size } = entry;
            const orderSize = Math.abs(remainingOrderSize) > size * price
                ? size
                : Math.abs(remainingOrderSize) / price;
            const roundedOrderSize = (0, rounder_1.quickRound)(orderSize, stepSize);
            quoteSizeTotal += roundedOrderSize;
            const orderCost = roundedOrderSize * price;
            baseSizeTotal += orderCost;
            worstPrice = price;
            marketOrderOrderBook.push(entry);
            remainingOrderSize -= isBuying ? orderCost : -orderCost;
            if (Math.abs(remainingOrderSize) < price * stepSize) {
                filled = true;
                break;
            }
        }
        return {
            quoteSizeTotal,
            baseSizeTotal,
            worstPrice,
            filled,
        };
    }
    calculateMarketOrderFromBaseSize(baseSize, market, isBuying) {
        if (!baseSize)
            return null;
        // const stepSize = market.configs.stepSize;
        const orderbookField = isBuying ? "asks" : "bids";
        const orderbook = (0, orderbook_1.getOrderbookFromStore)(this.store, market.market)[orderbookField];
        if (orderbook.length === 0)
            return null;
        let quoteSizeTotal = 0;
        let baseSizeTotal = 0;
        let worstPrice = null;
        let filled = false;
        const marketOrderOrderBook = [];
        for (const entry of orderbook) {
            const { price, size } = entry;
            if (price && price > 0 && size) {
                const entryBaseSize = size * price;
                filled = baseSizeTotal + entryBaseSize >= baseSize;
                let matchedQuoteSize = size;
                let matchedBaseSize = entryBaseSize;
                if (filled) {
                    matchedBaseSize = baseSize - baseSizeTotal;
                    matchedQuoteSize = matchedBaseSize / price;
                    // TODO: check if we should round here (abacus does, but if we do it breaks the number)
                    // matchedQuoteSize = quickRound(matchedQuoteSize, stepSize);
                    matchedBaseSize = matchedQuoteSize * price;
                }
                quoteSizeTotal += matchedQuoteSize;
                baseSizeTotal += matchedBaseSize;
                worstPrice = price;
                marketOrderOrderBook.push(entry);
                if (filled) {
                    break;
                }
            }
        }
        return {
            quoteSizeTotal,
            baseSizeTotal,
            worstPrice,
            filled,
        };
    }
    calculateMarketOrderFromQuoteSize(quoteSize, market, isBuying) {
        if (!quoteSize)
            return null;
        const orderbookField = isBuying ? "asks" : "bids";
        const orderbook = (0, orderbook_1.getOrderbookFromStore)(this.store, market.market)[orderbookField];
        if (orderbook.length === 0)
            return null;
        let quoteSizeTotal = 0;
        let baseSizeTotal = 0;
        let worstPrice = null;
        let filled = false;
        const marketOrderOrderBook = [];
        for (const entry of orderbook) {
            const { price, size } = entry;
            if (price && size) {
                filled = quoteSizeTotal + size >= quoteSize;
                const matchedQuoteSize = filled ? quoteSize - quoteSizeTotal : size;
                const matchedBaseSize = matchedQuoteSize * price;
                quoteSizeTotal += matchedQuoteSize;
                baseSizeTotal += matchedBaseSize;
                worstPrice = price;
                marketOrderOrderBook.push(entry);
                if (filled) {
                    break;
                }
            }
        }
        return {
            quoteSizeTotal,
            baseSizeTotal,
            worstPrice,
            filled,
        };
    }
    calculateLimitOrder(newInputs, fieldName, subaccount, isBuying) {
        const { marketId, price, baseSize, quoteSize, leverage } = newInputs;
        const storeState = this.store.getState();
        const newLimitOrder = { ...newInputs };
        const market = storeState.markets[marketId];
        if (!market)
            throw new Error(`Market ${marketId} not found.`);
        const stepSize = market.configs.stepSize;
        if (fieldName === "baseSize") {
            if (price && baseSize) {
                newLimitOrder.quoteSize = (0, rounder_1.round)(baseSize / price, stepSize);
            }
        }
        else if (fieldName === "quoteSize") {
            if (price && quoteSize) {
                newLimitOrder.baseSize = (0, rounder_1.round)(quoteSize * price, stepSize);
            }
        }
        else if (fieldName === "price") {
            if (price) {
                if (newLimitOrder.baseSize) {
                    newLimitOrder.quoteSize = (0, rounder_1.round)(newLimitOrder.baseSize / price, stepSize);
                }
                else if (newLimitOrder.quoteSize) {
                    newLimitOrder.baseSize = (0, rounder_1.round)(newLimitOrder.quoteSize * price, stepSize);
                }
            }
        }
        else if (fieldName === "leverage") {
            if (leverage) {
                const calculatedSize = this.calculateSizeFromLeverageAndLimitPrice(leverage, price, market, subaccount, isBuying);
                if (calculatedSize) {
                    newLimitOrder.quoteSize = calculatedSize;
                    newLimitOrder.baseSize = calculatedSize * price;
                }
            }
        }
        return newLimitOrder;
    }
    calculateSizeFromLeverageAndLimitPrice(leverage, limitPrice, market, subaccount, isBuying) {
        var _a;
        if (!leverage || !limitPrice)
            return null;
        const equity = subaccount.equity;
        // TODO: get user fee rate
        const feeRate = 0;
        const stepSize = market.configs.stepSize;
        const positions = subaccount.openPositions;
        const positionQuoteSize = (_a = positions === null || positions === void 0 ? void 0 : positions[market.id]) === null || _a === void 0 ? void 0 : _a.size;
        const orderSign = isBuying ? 1 : -1;
        if (!equity || !positionQuoteSize)
            return null;
        const orderSize = (leverage * equity - positionQuoteSize * limitPrice) /
            (limitPrice + orderSign * leverage * limitPrice * feeRate);
        const desiredSize = Math.abs(orderSize);
        if (desiredSize < positionQuoteSize) {
            return (0, rounder_1.quickRound)(orderSize, stepSize);
        }
        const rounded = (0, rounder_1.quickRound)(desiredSize, stepSize);
        return (0, rounder_1.quickRound)(rounded, stepSize);
    }
    updateForm(newState) {
        const formType = this.formType;
        const forms = this.store.getState().forms;
        this.store.setState({
            forms: {
                ...forms,
                [formType]: { ...forms[formType], ...newState },
            },
        });
    }
    isShortTermOrder(type, timeInForce) {
        if (type === forms_1.TradeFormType.MARKET) {
            return true;
        }
        else if (type === forms_1.TradeFormType.LIMIT) {
            if (timeInForce === shared_1.OrderTimeInForce.GTT) {
                return false;
            }
            return true;
        }
        return false;
    }
    // public convertToPayload(
    //   subaccountNumber: number,
    //   TODO: get currentHeight from other places (indexer and store on state for example)
    //   currentHeight: number
    // ): PlaceOrderPayload {
    //   const state = this.store.getState();
    //   const tradeForm = state.forms[FormType.TRADE];
    //   const tradeInputs = tradeForm.inputs;
    //   // random number between 0 and 2^32 - 1
    //   const clientId = Math.floor(Math.random() * (Number.MAX_SAFE_INTEGER - 1));
    //   const orderSubaccountNumber =
    //     tradeInputs.marginMode === MarginMode.ISOLATED
    //       ? this.getSubaccountNumberForIsolatedMarket(
    //           tradeInputs.marketId,
    //           subaccountNumber
    //         )
    //       : subaccountNumber;
    //   const market = state.markets[tradeInputs.marketId];
    //   if (!market) throw new Error(`Market ${tradeInputs.marketId} not found.`);
    //   const marketInfo: PlaceOrderMarketInfo = {
    //     clobPairId: market.configs.clobPairId,
    //     atomicResolution: market.configs.atomicResolution,
    //     stepBaseQuantums: market.configs.stepBaseQuantums,
    //     quantumConversionExponent: market.configs.quantumConversionExponent,
    //     subticksPerTick: market.configs.subticksPerTick,
    //   };
    //   // TODO: get triggerPrice if needed
    //   const triggerPrice = 0;
    //   // TODO: get postOnly if needed
    //   const postOnly = false;
    //   const reduceOnly = tradeInputs.reduceOnly || false;
    //   const timeInForce = !!tradeInputs.timeInForce
    //     ? tradeInputs.type === TradeFormType.MARKET
    //       ? OrderTimeInForce.IOC
    //       : tradeInputs.timeInForce || OrderTimeInForce.IOC
    //     : null;
    //   const execution = tradeInputs.execution || OrderExecution.DEFAULT;
    //   // TODO: calculate goodTilTimeInSeconds
    //   const goodTilTimeInSeconds = tradeInputs.goodTilTime || null;
    //   const goodTilBlock = this.isShortTermOrder(
    //     tradeInputs.type,
    //     tradeInputs.timeInForce
    //   )
    //     ? currentHeight + SHORT_TERM_ORDER_DURATION
    //     : null;
    //   return {
    //     subaccountNumber: orderSubaccountNumber,
    //     marketId: tradeInputs.marketId,
    //     clientId,
    //     type: tradeInputs.type,
    //     side: tradeInputs.side,
    //     price: tradeForm.summary?.price || 0,
    //     // TODO: check if it's baseSize or quoteSize
    //     size: tradeForm.summary?.baseSize || 0,
    //     triggerPrice,
    //     reduceOnly,
    //     postOnly,
    //     marketInfo,
    //     timeInForce,
    //     execution,
    //     goodTilTimeInSeconds,
    //     goodTilBlock,
    //     currentHeight,
    //   };
    // }
    getSubaccountNumberForIsolatedMarket(marketId, subaccountNumber) {
        const subaccounts = this.store.getState().user.account.subaccounts;
        const utilizedSubaccountsMarketIdMap = Object.entries(subaccounts).reduce((acc, [_, subaccount]) => {
            var _a;
            const openPositions = subaccount.openPositions;
            const openOrders = (_a = subaccount.orders) === null || _a === void 0 ? void 0 : _a.filter((order) => {
                const status = order.status;
                return [
                    shared_1.OrderStatusEnum.OPEN,
                    shared_1.OrderStatusEnum.PENDING,
                    shared_1.OrderStatusEnum.UNTRIGGERED,
                    shared_1.OrderStatusEnum.PARTIALLY_FILLED,
                ].includes(status.value);
            });
            const positionMarketIds = Object.values(openPositions !== null && openPositions !== void 0 ? openPositions : {}).map((position) => position.id);
            const openOrderMarketIds = (openOrders !== null && openOrders !== void 0 ? openOrders : []).map((order) => order.marketId);
            const uniqueMarketIds = [
                ...new Set([...positionMarketIds, ...openOrderMarketIds]),
            ];
            acc[subaccountNumber] = uniqueMarketIds;
            return acc;
        }, {});
        let availableSubaccountNumber = subaccountNumber;
        Object.entries(utilizedSubaccountsMarketIdMap).forEach(([key, marketIds]) => {
            var _a, _b;
            const subaccountNumberToCheck = parseInt(key);
            if (subaccountNumberToCheck !== subaccountNumber) {
                if (marketIds.includes(marketId) && marketIds.length <= 1) {
                    return subaccountNumberToCheck;
                }
                else if (marketIds.length === 0) {
                    const equity = (_b = (_a = subaccounts[subaccountNumberToCheck]) === null || _a === void 0 ? void 0 : _a.equity) !== null && _b !== void 0 ? _b : 0;
                    if (availableSubaccountNumber === subaccountNumber &&
                        equity === 0) {
                        availableSubaccountNumber = subaccountNumberToCheck;
                    }
                }
            }
        });
        if (availableSubaccountNumber !== subaccountNumber) {
            return availableSubaccountNumber;
        }
        const existingSubaccountNumbers = Object.keys(utilizedSubaccountsMarketIdMap);
        for (let offset = shared_2.NUM_PARENT_SUBACCOUNTS; offset <= shared_2.MAX_SUBACCOUNT_NUMBER; offset += shared_2.NUM_PARENT_SUBACCOUNTS) {
            const tentativeSubaccountNumber = offset + subaccountNumber;
            if (!existingSubaccountNumbers.includes(tentativeSubaccountNumber.toString())) {
                return tentativeSubaccountNumber;
            }
        }
        throw new Error("No available subaccount number");
    }
}
exports.TradeFormProcessor = TradeFormProcessor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZGUtZm9ybS5wcm9jZXNzb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvcHJvY2Vzc29ycy9mb3Jtcy90cmFkZS90cmFkZS1mb3JtLnByb2Nlc3Nvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwwQ0FBNkU7QUFDN0UsMENBQThFO0FBSTlFLDhEQUFpRTtBQUNqRSxnREFXOEI7QUFDOUIsb0RBQTJEO0FBQzNELHdEQUFpRTtBQUNqRSxnRUFBMkQ7QUFDM0QscUNBQW9EO0FBQ3BELG1GQUE2RTtBQUM3RSxtRkFBNkU7QUFTN0UsTUFBYSxrQkFBbUIsU0FBUSx1Q0FBaUI7SUFJdkQsWUFBWSxLQUFZO1FBQ3RCLEtBQUssQ0FBQyxLQUFLLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSwwREFBMEIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSwwREFBMEIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRU0sU0FBUztRQUNkLElBQUksQ0FBQyxVQUFVLENBQUMsaUNBQXdCLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU0sWUFBWSxDQUFDLFNBQThCLEVBQUUsS0FBYztRQUNoRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUkxQyxDQUFDO1FBQ0YsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxDQUFDO1FBQ2pFLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsZ0JBQWdCLGFBQWEs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