import { type WebSocketMessage } from "../websocket";

export enum IndexerPositionSide {
  LONG = "LONG",
  SHORT = "SHORT",
}

export enum IndexerOrderSide {
  BUY = "BUY",
  SELL = "SELL",
}

export enum IndexerPerpetualPositionStatus {
  OPEN = "OPEN",
  CLOSED = "CLOSED",
  LIQUIDATED = "LIQUIDATED",
}

export enum IndexerTimeInForce {
  GTT = "GTT",
  FOK = "FOK",
  IOC = "IOC",
  POST_ONLY = "POST_ONLY",
}

export enum IndexerOrderStatus {
  OPEN = "OPEN",
  FILLED = "FILLED",
  CANCELED = "CANCELED",
  BEST_EFFORT_CANCELED = "BEST_EFFORT_CANCELED",
  BEST_EFFORT_OPENED = "BEST_EFFORT_OPENED",
  UNTRIGGERED = "UNTRIGGERED",
}

export enum IndexerFillType {
  LIMIT = "LIMIT",
  LIQUIDATED = "LIQUIDATED",
  LIQUIDATION = "LIQUIDATION",
  DELEVERAGED = "DELEVERAGED",
  OFFSETTING = "OFFSETTING",
}

export enum IndexerLiquidity {
  TAKER = "TAKER",
  MAKER = "MAKER",
}

export enum IndexerTransferType {
  TRANSFER_IN = "TRANSFER_IN",
  TRANSFER_OUT = "TRANSFER_OUT",
  DEPOSIT = "DEPOSIT",
  WITHDRAWAL = "WITHDRAWAL",
}

export enum IndexerOrderType {
  LIMIT = "LIMIT",
  MARKET = "MARKET",
  STOP_LIMIT = "STOP_LIMIT",
  STOP_MARKET = "STOP_MARKET",
  TRAILING_STOP = "TRAILING_STOP",
  TAKE_PROFIT = "TAKE_PROFIT",
  TAKE_PROFIT_MARKET = "TAKE_PROFIT_MARKET",
  HARD_TRADE = "HARD_TRADE",
  FAILED_HARD_TRADE = "FAILED_HARD_TRADE",
  TRANSFER_PLACEHOLDER = "TRANSFER_PLACEHOLDER",
}

export interface IndexerSubaccountPerpetualPositionBatch {
  address: string;
  subaccountNumber: number;
  positionId: string;
  market: string;
  side: IndexerPositionSide;
  status: IndexerPerpetualPositionStatus;
  size: string;
  maxSize: string;
  netFunding: string;
  entryPrice: string;
  exitPrice?: string;
  sumOpen: string;
  sumClose: string;
  realizedPnl?: string;
  unrealizedPnl?: string;
}

// Note: the address and positionId are not present in the
// IndexerSubaccountResponse in the websocket "Subscribed" message
// They are only present in the "Batch Update" message
// TODO: see if this is the best way to handle it ^
export interface IndexerSubaccountAssetPosition {
  address?: string;
  positionId?: string;
  subaccountNumber: number;
  assetId: string;
  symbol: string;
  side: IndexerPositionSide;
  size: string;
}

export interface IndexerSubaccountOrder {
  id: string;
  subaccountId: string;
  clientId: string;
  clobPairId: string;
  side: IndexerOrderSide;
  size: string;
  ticker: string;
  price: string;
  type: IndexerOrderType;
  timeInForce: IndexerTimeInForce;
  postOnly: boolean;
  reduceOnly: boolean;
  status: IndexerOrderStatus;
  orderFlags: string;
  totalFilled?: string;
  totalOptimisticFilled?: string;
  goodTilBlock?: string;
  goodTilBlockTime?: string;
  triggerPrice?: string;
  updatedAt?: string;
  updatedAtHeight?: string;
  removalReason?: string;
  createdAtHeight?: string;
  clientMetadata: string;
}

export interface IndexerSubaccountFill {
  id: string;
  subaccountId: string;
  side: IndexerOrderSide;
  liquidity: IndexerLiquidity;
  type: IndexerFillType;
  clobPairId: string;
  size: string;
  price: string;
  fee: string;
  quoteAmount?: string;
  eventId: string;
  transactionHash?: string;
  createdAt: string;
  createdAtHeight: string;
  orderId?: string;
  ticker: string;
  clientMetadata?: string;
}

export interface IndexerSubaccountTransfer {
  sender: {
    address: string;
    subaccountNumber?: number;
  };
  recipient: {
    address: string;
    subaccountNumber?: number;
  };
  symbol: string;
  size: string;
  type: IndexerTransferType;
  transactionHash: string;
  createdAt: string;
  createdAtHeight: string;
}

export type IndexerSubaccountBatchUpdateMessageContents = {
  perpetualPositions?: IndexerSubaccountPerpetualPositionBatch[];
  assetPositions?: IndexerSubaccountAssetPosition[];
  orders?: IndexerSubaccountOrder[];
  fills?: IndexerSubaccountFill[];
  transfers?: IndexerSubaccountTransfer[];
}[];

export interface IndexerSubaccountPerpetualPositionSubscribed {
  market: string;
  status: IndexerPerpetualPositionStatus;
  side: IndexerPositionSide;
  size: string;
  maxSize: string;
  entryPrice: string;
  realizedPnl: string;
  createdAt: string;
  createdAtHeight: string;
  sumOpen: string;
  sumClose: string;
  netFunding: string;
  unrealizedPnl: string;
  closedAt?: string | null;
  exitPrice?: string | null;
  subaccountNumber: number;
}

export interface IndexerSubaccountResponse {
  address: string;
  subaccountNumber: number;
  equity: string;
  freeCollateral: string;
  openPerpetualPositions: Record<
    string,
    IndexerSubaccountPerpetualPositionSubscribed
  >;
  assetPositions: Record<string, IndexerSubaccountAssetPosition>;
  marginEnabled: boolean;
  updatedAtHeight: string;
  latestProcessedBlockHeight: string;
}

export interface IndexerSubaccountSubscribedContents {
  subaccount: {
    address: string;
    parentSubaccountNumber: number;
    equity: string;
    freeCollateral: string;
    childSubaccounts: IndexerSubaccountResponse[];
  };
  orders: IndexerSubaccountOrder[];
}

export type IndexerSubaccountSubscribedMessage =
  WebSocketMessage<IndexerSubaccountSubscribedContents>;

export type IndexerSubaccountBatchUpdateMessage =
  WebSocketMessage<IndexerSubaccountBatchUpdateMessageContents>;

// REST Responses

export interface IndexerSubaccountHistoricalPnl {
  id: string;
  subaccountId: string;
  equity: string;
  totalPnl: string;
  netTransfers: string;
  createdAt: string;
  blockHeight: string;
  blockTime: string;
}
