import { type Account, type GasPrice, type StdFee } from "@cosmjs/stargate";
import { type EncodeObject } from "@cosmjs/proto-signing";
import {
  type OrderExecution,
  type OrderSide,
  type OrderTimeInForce,
  type OrderType,
} from "@klyra/shared";
import { Method } from "@cosmjs/tendermint-rpc";
import {
  Order_ConditionType,
  type Order_TimeInForce,
} from "@klyra/proto/src/codegen/klyraprotocol/clob/order";
import Long from "long";
import { parseUnits } from "ethers";
import IndexerClient from "../indexer";
import { type LocalWallet } from "../lib/local-wallet";
import NodeClient from "../node";
import {
  type BroadcastMode,
  type IndexerClientConfig,
  type NodeClientConfig,
  OrderFlags,
  type TxResponsePromise,
} from "../types";
import {
  type WalletSubaccountInfo,
  type SubaccountInfo,
} from "../lib/subaccount";
import {
  calculateQuantums,
  calculateSubticks,
  calculateSide,
  calculateTimeInForce,
  calculateOrderFlags,
  calculateClientMetadata,
  calculateConditionType,
  calculateConditionalOrderTriggerSubticks,
} from "../utils/chain-helpers";
import { type OrderBatch } from "../lib/proto-includes";
import {
  SHORT_BLOCK_FORWARD,
  SHORT_BLOCK_WINDOW,
  TDAI_DECIMALS,
} from "../constants";
import { UserError } from "../lib/errors";
import { isStatefulOrder, verifyOrderFlags } from "../lib/validation";

interface ChainClientConfig {
  node: NodeClientConfig;
  indexer: IndexerClientConfig;
}

export interface MarketInfo {
  clobPairId: number;
  atomicResolution: number;
  stepBaseQuantums: number;
  quantumConversionExponent: number;
  subticksPerTick: number;
}

interface OrderBatchWithMarketId {
  marketId: string;
  clobPairId?: number;
  clientIds: number[];
}

export default class ChainClient {
  public isInitialized = false;
  public indexerClient: IndexerClient;
  public nodeClient: NodeClient;

  constructor(config: ChainClientConfig) {
    this.indexerClient = new IndexerClient({
      ...config.indexer,
    });
    this.nodeClient = new NodeClient({
      ...config.node,
    });
  }

  public async initialize(): Promise<void> {
    await this.nodeClient.initialize();
    this.isInitialized = true;
  }

  /**
   * @description Sign a list of messages with a wallet.
   * the calling function is responsible for creating the messages.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Signature.
   */
  async sign(
    wallet: LocalWallet,
    messaging: () => Promise<EncodeObject[]>,
    zeroFee: boolean,
    gasPrice?: GasPrice,
    memo?: string,
    account?: () => Promise<Account>
  ): Promise<Uint8Array> {
    return this.nodeClient.post.sign(
      wallet,
      messaging,
      zeroFee,
      gasPrice,
      memo,
      account
    );
  }

  /**
   * @description Send a list of messages with a wallet.
   * the calling function is responsible for creating the messages.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Transaction Hash.
   */
  async send(
    wallet: LocalWallet,
    messaging: () => Promise<EncodeObject[]>,
    zeroFee: boolean,
    gasPrice?: GasPrice,
    memo?: string,
    broadcastMode?: BroadcastMode,
    account?: () => Promise<Account>
  ): TxResponsePromise {
    return this.nodeClient.post.send(
      wallet,
      messaging,
      zeroFee,
      gasPrice,
      memo,
      broadcastMode,
      account
    );
  }

  /**
   * @description Send a signed transaction.
   *
   * @param signedTransaction The signed transaction to send.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Transaction Hash.
   */
  async sendSignedTransaction(
    signedTransaction: Uint8Array
  ): TxResponsePromise {
    return this.nodeClient.post.sendSignedTransaction(signedTransaction);
  }

  /**
   * @description Simulate a list of messages with a wallet.
   * the calling function is responsible for creating the messages.
   *
   * To send multiple messages with gas estimate:
   * 1. Client is responsible for creating the messages.
   * 2. Call simulate() to get the gas estimate.
   * 3. Call send() to send the messages.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The gas estimate.
   */
  async simulate(
    wallet: LocalWallet,
    messaging: () => Promise<EncodeObject[]>,
    gasPrice?: GasPrice,
    memo?: string,
    account?: () => Promise<Account>
  ): Promise<StdFee> {
    return this.nodeClient.post.simulate(
      wallet,
      messaging,
      gasPrice,
      memo,
      account
    );
  }

  /**
   * @description Calculate the goodTilBlock value for a SHORT_TERM order
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The goodTilBlock value
   */

  private async calculateGoodTilBlock(
    orderFlags: OrderFlags,
    currentHeight?: number,
    goodTilBlock?: number
  ): Promise<number> {
    if (orderFlags === OrderFlags.SHORT_TERM) {
      if (goodTilBlock) {
        return Promise.resolve(goodTilBlock);
      }
      const height =
        currentHeight ?? (await this.nodeClient.get.latestBlockHeight());
      return height + SHORT_BLOCK_FORWARD;
    }
    return Promise.resolve(0);
  }

  /**
   * @description Validate the goodTilBlock value for a SHORT_TERM order
   *
   * @param goodTilBlock Number of blocks from the current block height the order will
   * be valid for.
   *
   * @throws UserError if the goodTilBlock value is not valid given latest block height and
   * SHORT_BLOCK_WINDOW.
   */
  private async validateGoodTilBlock(goodTilBlock: number): Promise<void> {
    const height = await this.nodeClient.get.latestBlockHeight();
    const nextValidBlockHeight = height + 1;
    const lowerBound = nextValidBlockHeight;
    const upperBound = nextValidBlockHeight + SHORT_BLOCK_WINDOW;
    if (goodTilBlock < lowerBound || goodTilBlock > upperBound) {
      throw new UserError(`Invalid Short-Term order GoodTilBlock.
        Should be greater-than-or-equal-to ${lowerBound} and less-than-or-equal-to ${upperBound}.
        Provided good til block: ${goodTilBlock}`);
    }
  }

  /**
   * @description Calculate the goodTilBlockTime value for a LONG_TERM order
   * the calling function is responsible for creating the messages.
   *
   * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The goodTilBlockTime value
   */
  private calculateGoodTilBlockTime(goodTilTimeInSeconds: number): number {
    const now = new Date();
    const millisecondsPerSecond = 1000;
    const interval = goodTilTimeInSeconds * millisecondsPerSecond;
    const future = new Date(now.valueOf() + interval);
    return Math.round(future.getTime() / 1000);
  }

  /**
   * @description Place a short term order with human readable input.
   *
   * Use human readable form of input, including price and size
   * The quantum and subticks are calculated and submitted
   *
   * @param subaccount The subaccount to place the order under
   * @param marketId The market to place the order on
   * @param side The side of the order to place
   * @param price The price of the order to place
   * @param size The size of the order to place
   * @param clientId The client id of the order to place
   * @param timeInForce The time in force of the order to place
   * @param goodTilBlock The goodTilBlock of the order to place
   * @param reduceOnly The reduceOnly of the order to place
   *
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash.
   */
  async placeShortTermOrder(
    subaccount: WalletSubaccountInfo,
    marketId: string,
    side: OrderSide,
    price: number,
    size: number,
    clientId: number,
    goodTilBlock: number,
    timeInForce: Order_TimeInForce,
    reduceOnly: boolean,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    memo?: string
  ): TxResponsePromise {
    const msgs = new Promise<EncodeObject[]>((resolve, reject) => {
      const msg = this.placeShortTermOrderMessage(
        subaccount,
        marketId,
        side,
        price,
        size,
        clientId,
        goodTilBlock,
        timeInForce,
        reduceOnly,
        routerFeePpm,
        routerSubaccount
      );
      msg
        .then((it) => {
          resolve([it]);
        })
        .catch((err: unknown) => {
          reject(err instanceof Error ? err : new Error(String(err)));
        });
    });
    const account: Promise<Account> = this.nodeClient.post.account(
      subaccount.address,
      undefined
    );
    return this.send(
      subaccount.wallet,
      () => msgs,
      true,
      undefined,
      memo,
      undefined,
      () => account
    );
  }

  /**
   * @description Place an order with human readable input.
   *
   * Only MARKET and LIMIT types are supported right now
   * Use human readable form of input, including price and size
   * The quantum and subticks are calculated and submitted
   *
   * @param subaccount The subaccount to place the order on.
   * @param marketId The market to place the order on.
   * @param type The type of order to place.
   * @param side The side of the order to place.
   * @param price The price of the order to place.
   * @param size The size of the order to place.
   * @param clientId The client id of the order to place.
   * @param timeInForce The time in force of the order to place.
   * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
   * @param execution The execution of the order to place.
   * @param postOnly The postOnly of the order to place.
   * @param reduceOnly The reduceOnly of the order to place.
   * @param triggerPrice The trigger price of conditional orders.
   * @param marketInfo optional market information for calculating quantums and subticks.
   *        This can be constructed from Indexer API. If set to null, additional round
   *        trip to Indexer API will be made.
   * @param currentHeight Current block height. This can be obtained from nodeClient.
   *        If set to null, additional round trip to nodeClient will be made.
   *
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash.
   */
  async placeOrder(
    subaccount: WalletSubaccountInfo,
    marketId: string,
    type: OrderType,
    side: OrderSide,
    price: number,
    size: number,
    clientId: number,
    timeInForce?: OrderTimeInForce,
    goodTilTimeInSeconds?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    execution?: OrderExecution,
    postOnly?: boolean,
    reduceOnly?: boolean,
    triggerPrice?: number,
    marketInfo?: MarketInfo,
    currentHeight?: number,
    goodTilBlock?: number,
    memo?: string
  ): TxResponsePromise {
    const msgs = new Promise<EncodeObject[]>((resolve, reject) => {
      const msg = this.placeOrderMessage(
        subaccount,
        marketId,
        type,
        side,
        price,
        size,
        clientId,
        timeInForce,
        goodTilTimeInSeconds,
        routerFeePpm,
        routerSubaccount,
        execution,
        postOnly,
        reduceOnly,
        triggerPrice,
        marketInfo,
        currentHeight,
        goodTilBlock
      );
      msg
        .then((it) => {
          resolve([it]);
        })
        .catch((err: unknown) => {
          reject(err instanceof Error ? err : new Error(String(err)));
        });
    });
    const orderFlags = calculateOrderFlags(type, timeInForce);
    const account: Promise<Account> = this.nodeClient.post.account(
      subaccount.address,
      orderFlags
    );
    return this.send(
      subaccount.wallet,
      () => msgs,
      true,
      undefined,
      memo,
      undefined,
      () => account
    );
  }

  /**
   * @description Calculate and create the place order message
   *
   * Only MARKET and LIMIT types are supported right now
   * Use human readable form of input, including price and size
   * The quantum and subticks are calculated and submitted
   *
   * @param subaccount The subaccount to place the order under
   * @param marketId The market to place the order on
   * @param type The type of order to place
   * @param side The side of the order to place
   * @param price The price of the order to place
   * @param size The size of the order to place
   * @param clientId The client id of the order to place
   * @param timeInForce The time in force of the order to place
   * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place
   * @param routerFeePpm The ppm fee that goes to the exchange that routed the order
   * @param routerSubaccount The subaccount of the exchange that routed the order
   * @param execution The execution of the order to place
   * @param postOnly The postOnly of the order to place
   * @param reduceOnly The reduceOnly of the order to place
   *
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The message to be passed into the protocol
   */
  private async placeOrderMessage(
    subaccount: WalletSubaccountInfo,
    marketId: string,
    type: OrderType,
    side: OrderSide,
    price: number,
    // trigger_price: number,   // not used for MARKET and LIMIT
    size: number,
    clientId: number,
    timeInForce?: OrderTimeInForce,
    goodTilTimeInSeconds?: number,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo,
    execution?: OrderExecution,
    postOnly?: boolean,
    reduceOnly?: boolean,
    triggerPrice?: number,
    marketInfo?: MarketInfo,
    currentHeight?: number,
    goodTilBlock?: number
  ): Promise<EncodeObject> {
    const orderFlags = calculateOrderFlags(type, timeInForce);

    const result = await Promise.all([
      this.calculateGoodTilBlock(orderFlags, currentHeight, goodTilBlock),
      this.retrieveMarketInfo(marketId, marketInfo),
    ]);
    const desiredGoodTilBlock = result[0];
    const clobPairId = result[1].clobPairId;
    const atomicResolution = result[1].atomicResolution;
    const stepBaseQuantums = result[1].stepBaseQuantums;
    const quantumConversionExponent = result[1].quantumConversionExponent;
    const subticksPerTick = result[1].subticksPerTick;
    const orderSide = calculateSide(side);
    const quantums = calculateQuantums(
      size,
      atomicResolution,
      stepBaseQuantums
    );
    const subticks = calculateSubticks(
      price,
      atomicResolution,
      quantumConversionExponent,
      subticksPerTick
    );
    const orderTimeInForce = calculateTimeInForce(
      type,
      timeInForce,
      execution,
      postOnly
    );
    let goodTilBlockTime = 0;
    if (
      orderFlags === OrderFlags.LONG_TERM ||
      orderFlags === OrderFlags.CONDITIONAL
    ) {
      if (typeof goodTilTimeInSeconds === "undefined") {
        throw new Error(
          "goodTilTimeInSeconds must be set for LONG_TERM or CONDITIONAL order"
        );
      } else {
        goodTilBlockTime = this.calculateGoodTilBlockTime(goodTilTimeInSeconds);
      }
    }
    const clientMetadata = calculateClientMetadata(type);
    const conditionalType = calculateConditionType(type);
    const conditionalOrderTriggerSubticks =
      calculateConditionalOrderTriggerSubticks(
        type,
        atomicResolution,
        quantumConversionExponent,
        subticksPerTick,
        triggerPrice
      );

    if (routerFeePpm && !routerSubaccount) {
      throw new Error(
        "Cannot have router fee without specifying the router subaccount"
      );
    }

    return this.nodeClient.post.composer.composeMsgPlaceOrder(
      subaccount.address,
      subaccount.subaccountNumber,
      clientId,
      clobPairId,
      orderFlags,
      desiredGoodTilBlock,
      goodTilBlockTime,
      orderSide,
      quantums,
      subticks,
      routerFeePpm ?? 0,
      routerSubaccount?.address ?? "",
      routerSubaccount?.subaccountNumber ?? 0,
      orderTimeInForce,
      reduceOnly ?? false,
      clientMetadata,
      conditionalType,
      conditionalOrderTriggerSubticks
    );
  }

  private async retrieveMarketInfo(
    marketId: string,
    marketInfo?: MarketInfo
  ): Promise<MarketInfo> {
    if (marketInfo) {
      return Promise.resolve(marketInfo);
    }
    const market =
      await this.indexerClient.markets.getPerpetualMarket(marketId);
    const clobPairId = market.clobPairId;
    const atomicResolution = market.atomicResolution;
    const stepBaseQuantums = market.stepBaseQuantums;
    const quantumConversionExponent = market.quantumConversionExponent;
    const subticksPerTick = market.subticksPerTick;
    return {
      clobPairId: Number(clobPairId),
      atomicResolution: Number(atomicResolution),
      stepBaseQuantums: Number(stepBaseQuantums),
      quantumConversionExponent: Number(quantumConversionExponent),
      subticksPerTick: Number(subticksPerTick),
    };
  }

  /**
   * @description Calculate and create the short term place order message
   *
   * Use human readable form of input, including price and size
   * The quantum and subticks are calculated and submitted
   *
   * @param subaccount The subaccount to place the order under
   * @param marketId The market to place the order on
   * @param side The side of the order to place
   * @param price The price of the order to place
   * @param size The size of the order to place
   * @param clientId The client id of the order to place
   * @param timeInForce The time in force of the order to place
   * @param goodTilBlock The goodTilBlock of the order to place
   * @param reduceOnly The reduceOnly of the order to place
   *
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The message to be passed into the protocol
   */
  private async placeShortTermOrderMessage(
    subaccount: WalletSubaccountInfo,
    marketId: string,
    side: OrderSide,
    price: number,
    size: number,
    clientId: number,
    goodTilBlock: number,
    timeInForce: Order_TimeInForce,
    reduceOnly: boolean,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo
  ): Promise<EncodeObject> {
    await this.validateGoodTilBlock(goodTilBlock);

    const market =
      await this.indexerClient.markets.getPerpetualMarket(marketId);
    const clobPairId = market.clobPairId;
    const atomicResolution = market.atomicResolution;
    const stepBaseQuantums = market.stepBaseQuantums;
    const quantumConversionExponent = market.quantumConversionExponent;
    const subticksPerTick = market.subticksPerTick;
    const orderSide = calculateSide(side);
    const quantums = calculateQuantums(
      size,
      Number(atomicResolution),
      Number(stepBaseQuantums)
    );
    const subticks = calculateSubticks(
      price,
      atomicResolution,
      Number(quantumConversionExponent),
      Number(subticksPerTick)
    );

    const orderFlags = OrderFlags.SHORT_TERM;

    if (routerFeePpm && !routerSubaccount) {
      throw new Error(
        "Cannot have router fee without specifying the router subaccount"
      );
    }

    return this.nodeClient.post.composer.composeMsgPlaceOrder(
      subaccount.address,
      subaccount.subaccountNumber,
      clientId,
      Number(clobPairId),
      orderFlags,
      goodTilBlock,
      0, // Short term orders use goodTilBlock.
      orderSide,
      quantums,
      subticks,
      routerFeePpm ?? 0,
      routerSubaccount?.address ?? "",
      routerSubaccount?.subaccountNumber ?? 0,
      timeInForce,
      reduceOnly,
      0, // Client metadata is 0 for short term orders.
      Order_ConditionType.CONDITION_TYPE_UNSPECIFIED, // Short term orders cannot be conditional.
      Long.fromInt(0) // Short term orders cannot be conditional.
    );
  }

  /**
   * @description Cancel an order with order information from web socket or REST.
   *
   * @param subaccount The subaccount to cancel the order from
   * @param clientId The client id of the order to cancel
   * @param orderFlags The order flags of the order to cancel
   * @param clobPairId The clob pair id of the order to cancel
   * @param goodTilBlock The goodTilBlock of the order to cancel
   * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash.
   */
  async cancelRawOrder(
    subaccount: WalletSubaccountInfo,
    clientId: number,
    orderFlags: OrderFlags,
    clobPairId: number,
    goodTilBlock?: number,
    goodTilBlockTime?: number
  ): TxResponsePromise {
    return this.nodeClient.post.cancelOrder(
      subaccount,
      clientId,
      orderFlags,
      clobPairId,
      goodTilBlock,
      goodTilBlockTime
    );
  }

  /**
   * @description Cancel an order with human readable input.
   *
   * @param subaccount The subaccount to cancel the order from
   * @param clientId The client id of the order to cancel
   * @param orderFlags The order flags of the order to cancel
   * @param marketId The market to cancel the order on
   * @param goodTilBlock The goodTilBlock of the order to cancel
   * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash.
   */
  async cancelOrder(
    subaccount: WalletSubaccountInfo,
    clientId: number,
    orderFlags: OrderFlags,
    ticker: string,
    goodTilBlock?: number,
    goodTilTimeInSeconds?: number
  ): TxResponsePromise {
    const market = await this.indexerClient.markets.getPerpetualMarket(ticker);
    const clobPairId = market.clobPairId;

    if (!verifyOrderFlags(orderFlags)) {
      throw new Error(`Invalid order flags: ${orderFlags}`);
    }

    let goodTilBlockTime;
    if (isStatefulOrder(orderFlags)) {
      if (goodTilTimeInSeconds === undefined || goodTilTimeInSeconds === 0) {
        throw new Error(
          "goodTilTimeInSeconds must be set for LONG_TERM or CONDITIONAL order"
        );
      }
      if (goodTilBlock !== 0) {
        throw new Error(
          "goodTilBlock should be zero since LONG_TERM or CONDITIONAL orders " +
            "use goodTilTimeInSeconds instead of goodTilBlock."
        );
      }
      goodTilBlockTime = this.calculateGoodTilBlockTime(goodTilTimeInSeconds);
    } else {
      if (goodTilBlock === undefined || goodTilBlock === 0) {
        throw new Error("goodTilBlock must be non-zero for SHORT_TERM orders");
      }
      if (goodTilTimeInSeconds !== undefined && goodTilTimeInSeconds !== 0) {
        throw new Error(
          "goodTilTimeInSeconds should be zero since SHORT_TERM orders use goodTilBlock instead of goodTilTimeInSeconds."
        );
      }
    }

    return this.nodeClient.post.cancelOrder(
      subaccount,
      clientId,
      orderFlags,
      Number(clobPairId),
      goodTilBlock,
      goodTilBlockTime
    );
  }

  /**
   * @description Batch cancel short term orders using marketId to clobPairId translation.
   *
   * @param subaccount The subaccount to cancel the order from
   * @param shortTermOrders The list of short term order batches to cancel with marketId
   * @param goodTilBlock The goodTilBlock of the order to cancel
   * @returns The transaction hash.
   */
  async batchCancelShortTermOrdersWithMarketId(
    subaccount: WalletSubaccountInfo,
    shortTermOrders: OrderBatchWithMarketId[],
    goodTilBlock: number,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const orderBatches = await Promise.all(
      shortTermOrders.map(async ({ marketId, clobPairId, clientIds }) => ({
        clobPairId: Number(
          clobPairId ??
            (await this.indexerClient.markets.getPerpetualMarket(marketId))
              .clobPairId
        ),
        clientIds,
      }))
    );

    return this.nodeClient.post.batchCancelShortTermOrders(
      subaccount,
      orderBatches,
      goodTilBlock,
      broadcastMode
    );
  }

  /**
   * @description Batch cancel short term orders using clobPairId.
   *
   * @param subaccount The subaccount to cancel the order from
   * @param shortTermOrders The list of short term order batches to cancel with clobPairId
   * @param goodTilBlock The goodTilBlock of the order to cancel
   * @returns The transaction hash.
   */
  async batchCancelShortTermOrdersWithClobPairId(
    subaccount: WalletSubaccountInfo,
    shortTermOrders: OrderBatch[],
    goodTilBlock: number,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    return this.nodeClient.post.batchCancelShortTermOrders(
      subaccount,
      shortTermOrders,
      goodTilBlock,
      broadcastMode
    );
  }

  /**
   * @description Transfer from a subaccount to another subaccount
   *
   * @param subaccount The subaccount to transfer from
   * @param recipientAddress The recipient address
   * @param recipientSubaccountNumber The recipient subaccount number
   * @param amount The amount to transfer
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash.
   */
  async transferToSubaccount(
    subaccount: WalletSubaccountInfo,
    recipientAddress: string,
    recipientSubaccountNumber: number,
    amount: string,
    memo?: string,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msgs = new Promise<EncodeObject[]>((resolve) => {
      const msg = this.transferToSubaccountMessage(
        subaccount,
        recipientAddress,
        recipientSubaccountNumber,
        amount
      );
      resolve([msg]);
    });
    return this.send(
      subaccount.wallet,
      () => msgs,
      false,
      undefined,
      memo,
      broadcastMode ?? Method.BroadcastTxCommit
    );
  }

  /**
   * @description Create message to transfer from a subaccount to another subaccount
   *
   * @param subaccount The subaccount to transfer from
   * @param recipientAddress The recipient address
   * @param recipientSubaccountNumber The recipient subaccount number
   * @param amount The amount to transfer
   *
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The message
   */
  transferToSubaccountMessage(
    subaccount: WalletSubaccountInfo,
    recipientAddress: string,
    recipientSubaccountNumber: number,
    amount: string
  ): EncodeObject {
    const nodeClient = this.nodeClient;
    if (typeof nodeClient === "undefined") {
      throw new Error("nodeClient not set");
    }
    const quantums = parseUnits(amount, TDAI_DECIMALS);
    if (quantums > BigInt(Long.MAX_VALUE.toString())) {
      throw new Error("amount to large");
    }
    if (quantums < 0) {
      throw new Error("amount must be positive");
    }

    return this.nodeClient.post.composer.composeMsgTransfer(
      subaccount.address,
      subaccount.subaccountNumber,
      recipientAddress,
      recipientSubaccountNumber,
      0,
      Long.fromString(quantums.toString())
    );
  }

  /**
   * @description Deposit from wallet to subaccount
   *
   * @param subaccount The subaccount to deposit to
   * @param amount The amount to deposit
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash.
   */
  async depositToSubaccount(
    subaccount: WalletSubaccountInfo,
    amount: string,
    memo?: string
  ): TxResponsePromise {
    const msgs = new Promise<EncodeObject[]>((resolve) => {
      const msg = this.depositToSubaccountMessage(subaccount, amount);
      resolve([msg]);
    });
    return this.nodeClient.post.send(
      subaccount.wallet,
      () => msgs,
      false,
      undefined,
      memo
    );
  }

  /**
   * @description Create message to deposit from wallet to subaccount
   *
   * @param subaccount The subaccount to deposit to
   * @param amount The amount to deposit
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The message
   */
  depositToSubaccountMessage(
    subaccount: WalletSubaccountInfo,
    amount: string
  ): EncodeObject {
    const nodeClient = this.nodeClient;
    if (typeof nodeClient === "undefined") {
      throw new Error("nodeClient not set");
    }
    const quantums = parseUnits(amount, TDAI_DECIMALS);
    if (quantums > BigInt(Long.MAX_VALUE.toString())) {
      throw new Error("amount to large");
    }
    if (quantums < 0) {
      throw new Error("amount must be positive");
    }

    return this.nodeClient.post.composer.composeMsgDepositToSubaccount(
      subaccount.address,
      subaccount.subaccountNumber,
      0,
      Long.fromString(quantums.toString())
    );
  }

  /**
   * @description Withdraw from subaccount to wallet
   *
   * @param subaccount The subaccount to withdraw from
   * @param amount The amount to withdraw
   * @param recipient The recipient address, default to subaccount address
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The transaction hash
   */
  async withdrawFromSubaccount(
    subaccount: WalletSubaccountInfo,
    amount: string,
    recipient?: string,
    memo?: string
  ): TxResponsePromise {
    const msgs = new Promise<EncodeObject[]>((resolve) => {
      const msg = this.withdrawFromSubaccountMessage(
        subaccount,
        amount,
        recipient
      );
      resolve([msg]);
    });
    return this.send(subaccount.wallet, () => msgs, false, undefined, memo);
  }

  /**
   * @description Create message to withdraw from subaccount to wallet
   * with human readable input.
   *
   * @param subaccount The subaccount to withdraw from
   * @param amount The amount to withdraw
   * @param recipient The recipient address
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The message
   */
  withdrawFromSubaccountMessage(
    subaccount: WalletSubaccountInfo,
    amount: string,
    recipient?: string
  ): EncodeObject {
    const nodeClient = this.nodeClient;
    if (typeof nodeClient === "undefined") {
      throw new Error("nodeClient not set");
    }
    const quantums = parseUnits(amount, TDAI_DECIMALS);
    if (quantums > BigInt(Long.MAX_VALUE.toString())) {
      throw new Error("amount to large");
    }
    if (quantums < 0) {
      throw new Error("amount must be positive");
    }

    return this.nodeClient.post.composer.composeMsgWithdrawFromSubaccount(
      subaccount.address,
      subaccount.subaccountNumber,
      0,
      Long.fromString(quantums.toString()),
      recipient
    );
  }

  async signPlaceOrder(
    subaccount: WalletSubaccountInfo,
    marketId: string,
    type: OrderType,
    side: OrderSide,
    price: number,
    size: number,
    clientId: number,
    timeInForce: OrderTimeInForce,
    goodTilTimeInSeconds: number,
    execution: OrderExecution,
    postOnly: boolean,
    reduceOnly: boolean,
    routerFeePpm?: number,
    routerSubaccount?: SubaccountInfo
  ): Promise<string> {
    const msgs = new Promise<EncodeObject[]>((resolve) => {
      const msg = this.placeOrderMessage(
        subaccount,
        marketId,
        type,
        side,
        price,
        // trigger_price: number,   // not used for MARKET and LIMIT
        size,
        clientId,
        timeInForce,
        goodTilTimeInSeconds,
        routerFeePpm,
        routerSubaccount,
        execution,
        postOnly,
        reduceOnly
      );
      msg
        .then((it) => {
          resolve([it]);
        })
        .catch((err: unknown) => {
          throw err;
        });
    });
    const signature = await this.sign(subaccount.wallet, () => msgs, true);

    return btoa(
      String.fromCharCode.apply(null, Array.from(new Uint8Array(signature)))
    );
  }

  async signCancelOrder(
    subaccount: WalletSubaccountInfo,
    clientId: number,
    orderFlags: OrderFlags,
    clobPairId: number,
    goodTilBlock: number,
    goodTilBlockTime: number
  ): Promise<string> {
    const msgs = new Promise<EncodeObject[]>((resolve) => {
      const msg = this.nodeClient.post.composer.composeMsgCancelOrder(
        subaccount.address,
        subaccount.subaccountNumber,
        clientId,
        clobPairId,
        orderFlags,
        goodTilBlock,
        goodTilBlockTime
      );
      resolve([msg]);
    });
    const signature = await this.sign(subaccount.wallet, () => msgs, true);

    return btoa(
      String.fromCharCode.apply(null, Array.from(new Uint8Array(signature)))
    );
  }
}
