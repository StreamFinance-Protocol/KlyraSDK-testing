import { type EncodeObject, type Registry } from "@cosmjs/proto-signing";
import {
  type MsgBatchCancel,
  type OrderBatch,
} from "@klyra/proto/src/codegen/klyraprotocol/clob/tx";
import { type MsgSend } from "cosmjs-types/cosmos/bank/v1beta1/tx";
import { type Coin } from "cosmjs-types/cosmos/base/v1beta1/coin";
import { type Any } from "cosmjs-types/google/protobuf/any";
import Long from "long";
import protobuf from "protobufjs";
import { Messages } from "../constants";
import {
  type OrderId,
  type Order,
  Order_ConditionType,
  type Order_Side,
  type Order_TimeInForce,
  type MsgPlaceOrder,
  type MsgCancelOrder,
  type SubaccountId,
  type MsgCreateTransfer,
  type Transfer,
  type MsgDepositToSubaccount,
  type MsgWithdrawFromSubaccount,
} from "./proto-includes";

protobuf.util.Long = Long;
protobuf.configure();

export default class Composer {
  // ------------ x/clob ------------
  public composeMsgPlaceOrder(
    address: string,
    subaccountNumber: number,
    clientId: number,
    clobPairId: number,
    orderFlags: number,
    goodTilBlock: number,
    goodTilBlockTime: number,
    side: Order_Side,
    quantums: Long,
    subticks: Long,
    routerFeePpm: number,
    routerSubaccountAddress: string,
    routerSubaccountNumber: number,
    timeInForce: Order_TimeInForce,
    reduceOnly: boolean,
    clientMetadata: number,
    conditionType: Order_ConditionType = Order_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    conditionalOrderTriggerSubticks: Long = Long.fromInt(0)
  ): EncodeObject {
    this.validateGoodTilBlockAndTime(
      orderFlags,
      goodTilBlock,
      goodTilBlockTime
    );

    const subaccountId: SubaccountId = {
      owner: address,
      number: subaccountNumber,
    };

    const routerSubaccountId: SubaccountId = {
      owner: routerSubaccountAddress,
      number: routerSubaccountNumber,
    };

    const orderId: OrderId = {
      subaccountId,
      clientId,
      orderFlags,
      clobPairId,
    };

    const order: Order = {
      orderId,
      side,
      quantums,
      subticks,
      goodTilBlock: goodTilBlock === 0 ? undefined : goodTilBlock,
      goodTilBlockTime: goodTilBlock === 0 ? goodTilBlockTime : undefined,
      timeInForce,
      reduceOnly,
      clientMetadata,
      conditionType,
      conditionalOrderTriggerSubticks,
      routerFeePpm,
      routerSubaccountId,
    };
    const msg: MsgPlaceOrder = {
      order,
    };
    return {
      typeUrl: Messages.PLACE_ORDER,
      value: msg,
    };
  }

  public composeMsgCancelOrder(
    address: string,
    subaccountNumber: number,
    clientId: number,
    clobPairId: number,
    orderFlags: number,
    goodTilBlock: number,
    goodTilBlockTime: number
  ): EncodeObject {
    this.validateGoodTilBlockAndTime(
      orderFlags,
      goodTilBlock,
      goodTilBlockTime
    );

    const subaccountId: SubaccountId = {
      owner: address,
      number: subaccountNumber,
    };

    const orderId: OrderId = {
      subaccountId,
      clientId,
      orderFlags,
      clobPairId,
    };

    const msg: MsgCancelOrder = {
      orderId,
      goodTilBlock: goodTilBlock === 0 ? undefined : goodTilBlock,
      goodTilBlockTime: goodTilBlock === 0 ? goodTilBlockTime : undefined,
    };

    return {
      typeUrl: Messages.CANCEL_ORDER,
      value: msg,
    };
  }

  public composeMsgBatchCancelShortTermOrders(
    address: string,
    subaccountNumber: number,
    shortTermCancels: OrderBatch[],
    goodTilBlock: number
  ): EncodeObject {
    const subaccountId: SubaccountId = {
      owner: address,
      number: subaccountNumber,
    };

    const msg: MsgBatchCancel = {
      subaccountId,
      shortTermCancels,
      goodTilBlock,
    };

    return {
      typeUrl: Messages.BATCH_CANCEL,
      value: msg,
    };
  }

  // ------------ x/sending ------------
  public composeMsgTransfer(
    address: string,
    subaccountNumber: number,
    recipientAddress: string,
    recipientSubaccountNumber: number,
    assetId: number,
    amount: Long
  ): EncodeObject {
    const sender: SubaccountId = {
      owner: address,
      number: subaccountNumber,
    };
    const recipient: SubaccountId = {
      owner: recipientAddress,
      number: recipientSubaccountNumber,
    };

    const transfer: Transfer = {
      sender,
      recipient,
      assetId,
      amount,
    };

    const msg: MsgCreateTransfer = {
      transfer,
    };

    return {
      typeUrl: Messages.CREATE_TRANSFER,
      value: msg,
    };
  }

  public composeMsgDepositToSubaccount(
    address: string,
    subaccountNumber: number,
    assetId: number,
    quantums: Long
  ): EncodeObject {
    const recipient: SubaccountId = {
      owner: address,
      number: subaccountNumber,
    };

    const msg: MsgDepositToSubaccount = {
      sender: address,
      recipient,
      assetId,
      quantums,
    };

    return {
      typeUrl: Messages.DEPOSIT_TO_SUBACCOUNT,
      value: msg,
    };
  }

  public composeMsgWithdrawFromSubaccount(
    address: string,
    subaccountNumber: number,
    assetId: number,
    quantums: Long,
    recipient: string = address
  ): EncodeObject {
    const sender: SubaccountId = {
      owner: address,
      number: subaccountNumber,
    };

    const msg: MsgWithdrawFromSubaccount = {
      sender,
      recipient,
      assetId,
      quantums,
    };

    return {
      typeUrl: Messages.WITHDRAW_FROM_SUBACCOUNT,
      value: msg,
    };
  }

  // ------------ x/bank ------------
  public composeMsgSendToken(
    address: string,
    recipient: string,
    coinDenom: string,
    quantums: string
  ): EncodeObject {
    const coin: Coin = {
      denom: coinDenom,
      amount: quantums,
    };

    const msg: MsgSend = {
      fromAddress: address,
      toAddress: recipient,
      amount: [coin],
    };

    return {
      typeUrl: Messages.SEND,
      value: msg,
    };
  }

  // ------------ util ------------
  public validateGoodTilBlockAndTime(
    orderFlags: number,
    goodTilBlock: number,
    goodTilBlockTime: number
  ): void {
    if (orderFlags === 0 && goodTilBlock === 0) {
      throw new Error("goodTilBlock must be set if orderFlags is 0");
    } else if (orderFlags !== 0 && goodTilBlockTime === 0) {
      throw new Error("goodTilBlockTime must be set if orderFlags is not 0");
    }
  }

  public wrapMessageAsAny(registry: Registry, message: EncodeObject): Any {
    return registry.encodeAsAny(message);
  }

  public wrapMessageArrAsAny(
    registry: Registry,
    messages: EncodeObject[]
  ): Any[] {
    const encodedMessages: Any[] = messages.map((message: EncodeObject) =>
      this.wrapMessageAsAny(registry, message)
    );
    return encodedMessages;
  }
}
