import { toHex } from "@cosmjs/encoding";
import Long from "long";
import { DEFAULT_SEQUENCE } from "../constants";
import {
  type TransactionOptions,
  type PartialTransactionOptions,
} from "../types";

/**
 * @description Either return undefined or insert default sequence value into
 * `partialTransactionOptions` if it does not exist.
 *
 * @returns undefined or full TransactionOptions.
 */
export function convertPartialTransactionOptionsToFull(
  partialTransactionOptions?: PartialTransactionOptions
): TransactionOptions | undefined {
  if (partialTransactionOptions === undefined) {
    return undefined;
  }

  return {
    sequence: DEFAULT_SEQUENCE,
    ...partialTransactionOptions,
  };
}

/**
 * @description Strip '0x' prefix from input string. If there is no '0x' prefix, return the original
 * input.
 *
 * @returns input without '0x' prefix or original input if no prefix.
 */
export function stripHexPrefix(input: string): string {
  if (input.startsWith("0x")) {
    return input.slice(2);
  }

  return input;
}

function toBigInt(u: Uint8Array): bigint {
  if (u.length <= 1) {
    return BigInt(0);
  }
  // eslint-disable-next-line no-bitwise -- bitwise operations are needed here
  const negated: boolean = (u[0]! & 1) === 1;
  const hex: string = Array.from(u.slice(1))
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
  const abs = BigInt(`0x${hex}`);
  return negated ? -abs : abs;
}

export function bigIntToBytes(value: bigint): Uint8Array {
  const absoluteValue = value < 0 ? value * BigInt(-1) : value;
  const nonPaddedHexValue = absoluteValue.toString(16);
  const paddedHexValue =
    nonPaddedHexValue.length % 2 === 0
      ? nonPaddedHexValue
      : `0${nonPaddedHexValue}`;
  const numberBytes = new Uint8Array(
    paddedHexValue.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))
  );
  const signedBytes = new Uint8Array([value < 0 ? 3 : 2, ...numberBytes]);
  return signedBytes;
}

export enum ByteArrayEncoding {
  HEX = "hex",
  BIGINT = "bigint",
}

/* eslint-disable @typescript-eslint/no-unsafe-member-access -- any and unsafe member access needed for JSON replacer function */
/* eslint-disable @typescript-eslint/no-unsafe-argument -- unsafe argument needed for JSON replacer function */
/* eslint-disable @typescript-eslint/no-unsafe-return -- any is needed for JSON replacer function */
// TODO: Add better type safety for this function
export function encodeJson(
  object?: Record<string, unknown>,
  byteArrayEncoding: ByteArrayEncoding = ByteArrayEncoding.HEX
): string {
  return JSON.stringify(object, function replacer(_key, value) {
    // Even though we set the an UInt8Array as the value,
    // it comes in here as an object with UInt8Array as the buffer property.
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (value instanceof Long) {
      return value.toString();
    }
    if (value?.buffer instanceof Uint8Array) {
      if (byteArrayEncoding === ByteArrayEncoding.HEX) {
        return toHex(value.buffer);
      }
      return toBigInt(value.buffer).toString();
    } else if (value instanceof Uint8Array) {
      if (byteArrayEncoding === ByteArrayEncoding.HEX) {
        return toHex(value);
      }
      return toBigInt(value).toString();
    }
    return value;
  });
}
