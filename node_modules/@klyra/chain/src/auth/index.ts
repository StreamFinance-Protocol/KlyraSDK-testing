import { HDKey } from "@scure/bip32";
import { entropyToMnemonic, mnemonicToSeedSync } from "@scure/bip39";
import { keccak256 } from "ethereum-cryptography/keccak";
import { wordlist } from "@scure/bip39/wordlists/english";
import { stripHexPrefix } from "../utils/helpers";
import { LocalWallet } from "../lib/local-wallet";
import { BECH32_PREFIX } from "../constants";

type Wallet = LocalWallet;
type PrivateKey = Uint8Array | null;
type PublicKey = Uint8Array | null;
type Mnemonic = string;

export async function getAccountFromUUID(uuid: string): Promise<{
  wallet: Wallet;
  mnemonic: Mnemonic;
  privateKey: PrivateKey;
  publicKey: PublicKey;
}> {
  let buffer = new TextEncoder().encode(uuid);

  if (buffer.length < 65) {
    const padding = new Uint8Array(65 - buffer.length);
    buffer = new Uint8Array([...buffer, ...padding]);
  }

  if (buffer.length > 65) {
    buffer = buffer.slice(0, 65);
  }

  const adjustedUUID = Array.from(buffer)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");

  const { mnemonic, privateKey, publicKey } = getHDKeyFromMessage(adjustedUUID);
  // Create wallet from mnemonic
  const wallet = await LocalWallet.fromMnemonic(mnemonic, BECH32_PREFIX);

  return {
    wallet,
    mnemonic,
    privateKey,
    publicKey,
  };
}

export async function getAccountFromCredentials(
  username: string,
  pwd: string
): Promise<{
  wallet: Wallet;
  mnemonic: Mnemonic;
  privateKey: PrivateKey;
  publicKey: PublicKey;
}> {
  const usernameHash = keccak256(new TextEncoder().encode(username));
  const pwdHash = keccak256(new TextEncoder().encode(pwd));

  const concatenatedHashes = new Uint8Array([
    ...usernameHash,
    ...pwdHash,
    0x01,
  ]);

  const { mnemonic, privateKey, publicKey } = getHDKeyFromMessage(
    Array.from(concatenatedHashes)
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("")
  );

  const wallet = await LocalWallet.fromMnemonic(mnemonic, BECH32_PREFIX);

  return {
    wallet,
    mnemonic,
    privateKey,
    publicKey,
  };
}

export async function getAccountFromSignedMessage(
  signedMessage: string
): Promise<{
  wallet: Wallet;
  mnemonic: Mnemonic;
  privateKey: PrivateKey;
  publicKey: PublicKey;
}> {
  const { mnemonic, privateKey, publicKey } =
    getHDKeyFromMessage(signedMessage);

  const wallet = await LocalWallet.fromMnemonic(mnemonic, BECH32_PREFIX);

  return {
    wallet,
    mnemonic,
    privateKey,
    publicKey,
  };
}

function getHDKeyFromMessage(message: string): {
  mnemonic: Mnemonic;
  privateKey: PrivateKey;
  publicKey: PublicKey;
} {
  const buffer = new Uint8Array(
    stripHexPrefix(message)
      .match(/.{1,2}/g)
      ?.map((byte) => parseInt(byte, 16)) ?? []
  );

  if (buffer.length !== 65) {
    throw new Error("Message must be 65 bytes");
  }

  // Remove the 'v' value by taking only the first 64 bytes of the message
  const rsValues = buffer.slice(0, 64);
  // Hash the 'r' and 's' values down to 32 bytes (256 bits) using Keccak-256
  const entropy = keccak256(rsValues);
  return exportMnemonicAndPrivateKey(entropy);
}

function exportMnemonicAndPrivateKey(
  entropy: Uint8Array,
  path = "m/44'/118'/0'/0/0"
): {
  mnemonic: Mnemonic;
  privateKey: PrivateKey;
  publicKey: PublicKey;
} {
  const mnemonic = entropyToMnemonic(entropy, wordlist);
  const { privateKey, publicKey } = deriveHDKeyFromMnemonic(mnemonic, path);
  return {
    mnemonic,
    privateKey,
    publicKey,
  };
}

function deriveHDKeyFromMnemonic(
  mnemonic: string,
  path: string
): {
  privateKey: PrivateKey;
  publicKey: PublicKey;
} {
  const seed = mnemonicToSeedSync(mnemonic);

  const hdkey = HDKey.fromMasterSeed(seed);
  const derivedHdkey = hdkey.derive(path);

  if (!hdkey.privateKey) {
    throw new Error("null hd key");
  }

  return {
    privateKey: derivedHdkey.privateKey,
    publicKey: derivedHdkey.publicKey,
  };
}
