import { type Secp256k1Pubkey } from "@cosmjs/amino";
import { Uint53 } from "@cosmjs/math";
import { type EncodeObject, type Registry } from "@cosmjs/proto-signing";
import {
  type Account,
  calculateFee,
  GasPrice,
  type StdFee,
} from "@cosmjs/stargate";
import { Method } from "@cosmjs/tendermint-rpc";
import Long from "long";
import protobuf from "protobufjs";
import { GAS_MULTIPLIER, TDAI_DENOM } from "../constants";
import { UnexpectedClientError } from "../lib/errors";
import { generateRegistry } from "../lib/registry";
import {
  type SubaccountInfo,
  type WalletSubaccountInfo,
} from "../lib/subaccount";
import {
  OrderFlags,
  type BroadcastMode,
  type TransactionOptions,
  type IPlaceOrder,
  type ICancelOrder,
  type TxResponsePromise,
} from "../types";
import Composer from "../lib/composer";
import { type LocalWallet } from "../lib/local-wallet";
import {
  type Order_Side,
  type Order_TimeInForce,
  type Any,
  type MsgPlaceOrder,
  type MsgCancelOrder,
  Order_ConditionType,
  type OrderBatch,
} from "../lib/proto-includes";
import type NodeGet from "./node-get";

// Required for encoding and decoding queries that are of type Long.
// Must be done once but since the individal modules should be usable
// - must be set in each module that encounters encoding/decoding Longs.
// Reference: https://github.com/protobufjs/protobuf.js/issues/921
protobuf.util.Long = Long;
protobuf.configure();

export default class NodePost {
  public readonly composer: Composer;
  private readonly registry: Registry;
  private readonly chainId: string;
  public readonly get: NodeGet;
  public readonly defaultClientMemo?: string;

  public readonly defaultGasPrice: GasPrice;

  public useTimestampNonce = false;
  private accountNumberCache = new Map<string, Account>();

  constructor(
    get: NodeGet,
    chainId: string,
    defaultClientMemo?: string,
    useTimestampNonce?: boolean
  ) {
    this.get = get;
    this.chainId = chainId;
    this.registry = generateRegistry();
    this.composer = new Composer();
    this.defaultClientMemo = defaultClientMemo;
    this.defaultGasPrice = GasPrice.fromString(`0.025${TDAI_DENOM}`);
    if (useTimestampNonce === true) this.useTimestampNonce = useTimestampNonce;
  }

  /**
   * @description Retrieves the account number for the given wallet address and populates the accountNumberCache.
   * The account number is required for txOptions when signing a transaction.
   * Pre-populating the cache avoids a round-trip request during the first transaction creation in the session, preventing it from being a performance blocker.
   */
  public async populateAccountNumberCache(address: string): Promise<void> {
    if (this.accountNumberCache.has(address)) return;

    const account = await this.get.getAccount(address);
    this.accountNumberCache.set(address, account);
  }

  getGasPrice(): GasPrice {
    return this.defaultGasPrice;
  }

  /**
   * @description Simulate a transaction
   * the calling function is responsible for creating the messages.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Fee for broadcasting a transaction.
   */
  async simulate(
    wallet: LocalWallet,
    messaging: () => Promise<EncodeObject[]>,
    gasPrice: GasPrice = this.getGasPrice(),
    memo?: string,
    account?: () => Promise<Account>
  ): Promise<StdFee> {
    let msgs: EncodeObject[];
    // protocol expects timestamp nonce in UTC milliseconds, which is the unit returned by Date.now()
    let sequence = Date.now();

    if (this.useTimestampNonce) {
      msgs = await messaging();
    } else {
      const msgsPromise = messaging();
      const accountPromise = account
        ? await account()
        : this.account(wallet.getAddress());
      const msgsAndAccount = await Promise.all([msgsPromise, accountPromise]);
      msgs = msgsAndAccount[0];
      sequence = msgsAndAccount[1].sequence;
    }

    return this.simulateTransaction(
      wallet.getPubKey(),
      sequence,
      msgs,
      gasPrice,
      memo
    );
  }

  /**
   * @description Sign a transaction
   * the calling function is responsible for creating the messages.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Signature.
   */
  async sign(
    wallet: LocalWallet,
    messaging: () => Promise<EncodeObject[]>,
    zeroFee: boolean,
    gasPrice: GasPrice = this.getGasPrice(),
    memo?: string,
    account?: () => Promise<Account>
  ): Promise<Uint8Array> {
    const msgsPromise = await messaging();
    const accountPromise = account
      ? await account()
      : this.account(wallet.getAddress());
    const msgsAndAccount = await Promise.all([msgsPromise, accountPromise]);
    const msgs = msgsAndAccount[0];
    return this.signTransaction(
      wallet,
      msgs,
      msgsAndAccount[1],
      zeroFee,
      gasPrice,
      memo
    );
  }

  /**
   * @description Send a transaction
   * the calling function is responsible for creating the messages.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Tx Hash.
   */
  async send(
    wallet: LocalWallet,
    messaging: () => Promise<EncodeObject[]>,
    zeroFee: boolean,
    gasPrice: GasPrice = this.getGasPrice(),
    memo?: string,
    broadcastMode?: BroadcastMode,
    account?: () => Promise<Account>,
    gasAdjustment: number = GAS_MULTIPLIER
  ): TxResponsePromise {
    const msgsPromise = messaging();
    const accountPromise = account
      ? await account()
      : this.account(wallet.getAddress());
    const msgsAndAccount = await Promise.all([msgsPromise, accountPromise]);
    const msgs = msgsAndAccount[0];

    return this.signAndSendTransaction(
      wallet,
      msgsAndAccount[1],
      msgs,
      zeroFee,
      gasPrice,
      memo ?? this.defaultClientMemo,
      broadcastMode ?? this.defaultBroadcastMode(msgs),
      gasAdjustment
    );
  }

  /**
   * @description Calculate the default broadcast mode.
   */
  private defaultBroadcastMode(msgs: EncodeObject[]): BroadcastMode {
    if (
      msgs.length === 1 &&
      (msgs[0]?.typeUrl === "/klyraprotocol.clob.MsgPlaceOrder" ||
        msgs[0]?.typeUrl === "/klyraprotocol.clob.MsgCancelOrder")
    ) {
      const orderFlags =
        msgs[0]?.typeUrl === "/klyraprotocol.clob.MsgPlaceOrder"
          ? (msgs[0]?.value as MsgPlaceOrder).order?.orderId?.orderFlags
          : (msgs[0]?.value as MsgCancelOrder).orderId?.orderFlags;

      switch (orderFlags) {
        case OrderFlags.SHORT_TERM:
          return Method.BroadcastTxSync;

        case OrderFlags.LONG_TERM:
        case OrderFlags.CONDITIONAL:
          return Method.BroadcastTxCommit;

        default:
          break;
      }
    }
    return Method.BroadcastTxSync;
  }

  /**
   * @description Sign and send a message
   *
   * @returns The Tx Response.
   */
  private async signTransaction(
    wallet: LocalWallet,
    messages: EncodeObject[],
    account: Account,
    zeroFee: boolean,
    gasPrice: GasPrice = this.getGasPrice(),
    memo?: string,
    gasAdjustment: number = GAS_MULTIPLIER
  ): Promise<Uint8Array> {
    // protocol expects timestamp nonce in UTC milliseconds, which is the unit returned by Date.now()
    const sequence = this.useTimestampNonce ? Date.now() : account.sequence;
    // Simulate transaction if no fee is specified.
    const fee: StdFee = zeroFee
      ? {
          amount: [],
          gas: "1000000",
        }
      : await this.simulateTransaction(
          wallet.getPubKey(),
          sequence,
          messages,
          gasPrice,
          memo,
          gasAdjustment
        );

    const txOptions: TransactionOptions = {
      sequence,
      accountNumber: account.accountNumber,
      chainId: this.chainId,
    };
    // Generate signed transaction.
    return wallet.signTransaction(messages, txOptions, fee, memo);
  }

  /**
   * @description Retrieve an account structure for transactions.
   * For short term orders, the sequence doesn't matter. Use cached if available.
   * For long term and conditional orders, a round trip to validator must be made.
   * when timestamp nonce is supported, no need to fetch account sequence number
   */
  public async account(
    address: string,
    orderFlags?: OrderFlags
  ): Promise<Account> {
    if (orderFlags === OrderFlags.SHORT_TERM || this.useTimestampNonce) {
      if (this.accountNumberCache.has(address)) {
        // If order is SHORT_TERM or if timestamp nonce is enabled, the sequence doesn't matter
        return this.accountNumberCache.get(address)!;
      }
    }
    const account = await this.get.getAccount(address);
    this.accountNumberCache.set(address, account);
    return account;
  }

  /**
   * @description Sign and send a message
   *
   * @returns The Tx Response.
   */
  private async signAndSendTransaction(
    wallet: LocalWallet,
    account: Account,
    messages: EncodeObject[],
    zeroFee: boolean,
    gasPrice: GasPrice = this.getGasPrice(),
    memo?: string,
    broadcastMode?: BroadcastMode,
    gasAdjustment: number = GAS_MULTIPLIER
  ): TxResponsePromise {
    const signedTransaction = await this.signTransaction(
      wallet,
      messages,
      account,
      zeroFee,
      gasPrice,
      memo,
      gasAdjustment
    );
    return this.sendSignedTransaction(signedTransaction, broadcastMode);
  }

  /**
   * @description Send signed transaction.
   *
   * @returns The Tx Response.
   */
  async sendSignedTransaction(
    signedTransaction: Uint8Array,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    return this.get.tendermintClient.broadcastTransaction(
      signedTransaction,
      broadcastMode ?? Method.BroadcastTxSync
    );
  }

  /**
   * @description Simulate broadcasting a transaction.
   *
   * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
   * at any point.
   * @returns The Fee for broadcasting a transaction.
   */
  private async simulateTransaction(
    pubKey: Secp256k1Pubkey,
    sequence: number,
    messages: readonly EncodeObject[],
    gasPrice: GasPrice = this.getGasPrice(),
    memo?: string,
    gasAdjustment: number = GAS_MULTIPLIER
  ): Promise<StdFee> {
    // Get simulated response.
    const encodedMessages: Any[] = messages.map((message: EncodeObject) =>
      this.registry.encodeAsAny(message)
    );
    const simulationResponse = await this.get.stargateQueryClient.tx.simulate(
      encodedMessages,
      memo,
      pubKey,
      sequence
    );

    // The promise should have been rejected if the gasInfo was undefined.
    if (simulationResponse.gasInfo === undefined) {
      throw new UnexpectedClientError();
    }

    // Calculate and return fee from gasEstimate.
    const gasEstimate: number = Uint53.fromString(
      simulationResponse.gasInfo.gasUsed.toString()
    ).toNumber();
    const fee = calculateFee(Math.floor(gasEstimate * gasAdjustment), gasPrice);

    // TODO: see if we should uncomment this or not
    // Temporary workaround before IBC denom is supported in '@cosmjs/stargate'.
    // The '@cosmjs/stargate' does not support denom with '/', so currently GAS_PRICE is
    // represented in 'uusdc', and the output of `calculateFee` is in '', which is replaced
    // below by USDC_DENOM string.
    // const amount: Coin[] = fee.amount.map((coin: Coin) => {
    //   if (coin.denom === "uusdc") {
    //     return {
    //       amount: coin.amount,
    //       denom: this.denoms.USDC_DENOM,
    //     };
    //   }
    //   return coin;
    // });

    // return {
    //   ...fee,
    //   amount,
    // };

    return fee;
  }

  // ------ State-Changing Requests ------ //

  async placeOrder(
    subaccount: WalletSubaccountInfo,
    clientId: number,
    clobPairId: number,
    side: Order_Side,
    quantums: Long,
    subticks: Long,
    routerFeePpm: number,
    routerSubaccount: SubaccountInfo,
    timeInForce: Order_TimeInForce,
    orderFlags: number,
    reduceOnly: boolean,
    goodTilBlock?: number,
    goodTilBlockTime?: number,
    clientMetadata = 0,
    conditionType: Order_ConditionType = Order_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    conditionalOrderTriggerSubticks: Long = Long.fromInt(0),
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.placeOrderMsg(
      subaccount.address,
      subaccount.subaccountNumber,
      clientId,
      clobPairId,
      side,
      quantums,
      subticks,
      routerFeePpm,
      routerSubaccount.address,
      routerSubaccount.subaccountNumber,
      timeInForce,
      orderFlags,
      reduceOnly,
      goodTilBlock,
      goodTilBlockTime,
      clientMetadata,
      conditionType,
      conditionalOrderTriggerSubticks
    );
    const account: Promise<Account> = this.account(
      subaccount.address,
      orderFlags
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      true,
      undefined,
      undefined,
      broadcastMode,
      () => account
    );
  }

  async placeOrderMsg(
    address: string,
    subaccountNumber: number,
    clientId: number,
    clobPairId: number,
    side: Order_Side,
    quantums: Long,
    subticks: Long,
    routerFeePpm: number,
    routerSubaccountAddress: string,
    routerSubaccountNumber: number,
    timeInForce: Order_TimeInForce,
    orderFlags: number,
    reduceOnly: boolean,
    goodTilBlock?: number,
    goodTilBlockTime?: number,
    clientMetadata = 0,
    conditionType: Order_ConditionType = Order_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    conditionalOrderTriggerSubticks: Long = Long.fromInt(0)
  ): Promise<EncodeObject> {
    return new Promise((resolve) => {
      const msg = this.composer.composeMsgPlaceOrder(
        address,
        subaccountNumber,
        clientId,
        clobPairId,
        orderFlags,
        goodTilBlock ?? 0,
        goodTilBlockTime ?? 0,
        side,
        quantums,
        subticks,
        routerFeePpm,
        routerSubaccountAddress,
        routerSubaccountNumber,
        timeInForce,
        reduceOnly,
        clientMetadata,
        conditionType,
        conditionalOrderTriggerSubticks
      );
      resolve(msg);
    });
  }

  async placeOrderObject(
    subaccount: WalletSubaccountInfo,
    routerSubaccount: SubaccountInfo,
    placeOrder: IPlaceOrder,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    return this.placeOrder(
      subaccount,
      placeOrder.clientId,
      placeOrder.clobPairId,
      placeOrder.side,
      placeOrder.quantums,
      placeOrder.subticks,
      placeOrder.routerFeePpm,
      routerSubaccount,
      placeOrder.timeInForce,
      placeOrder.orderFlags,
      placeOrder.reduceOnly,
      placeOrder.goodTilBlock,
      placeOrder.goodTilBlockTime,
      placeOrder.clientMetadata,
      placeOrder.conditionType ??
        Order_ConditionType.CONDITION_TYPE_UNSPECIFIED,
      placeOrder.conditionalOrderTriggerSubticks ?? Long.fromInt(0),
      broadcastMode
    );
  }

  async cancelOrder(
    subaccount: WalletSubaccountInfo,
    clientId: number,
    orderFlags: OrderFlags,
    clobPairId: number,
    goodTilBlock?: number,
    goodTilBlockTime?: number,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.cancelOrderMsg(
      subaccount.address,
      subaccount.subaccountNumber,
      clientId,
      orderFlags,
      clobPairId,
      goodTilBlock ?? 0,
      goodTilBlockTime ?? 0
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      true,
      undefined,
      undefined,
      broadcastMode
    );
  }

  async cancelOrderMsg(
    address: string,
    subaccountNumber: number,
    clientId: number,
    orderFlags: OrderFlags,
    clobPairId: number,
    goodTilBlock?: number,
    goodTilBlockTime?: number
  ): Promise<EncodeObject> {
    return new Promise((resolve) => {
      const msg = this.composer.composeMsgCancelOrder(
        address,
        subaccountNumber,
        clientId,
        clobPairId,
        orderFlags,
        goodTilBlock ?? 0,
        goodTilBlockTime ?? 0
      );
      resolve(msg);
    });
  }

  async cancelOrderObject(
    subaccount: WalletSubaccountInfo,
    cancelOrder: ICancelOrder,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    return this.cancelOrder(
      subaccount,
      cancelOrder.clientId,
      cancelOrder.orderFlags,
      cancelOrder.clobPairId,
      cancelOrder.goodTilBlock,
      cancelOrder.goodTilBlockTime,
      broadcastMode
    );
  }

  async batchCancelShortTermOrders(
    subaccount: WalletSubaccountInfo,
    shortTermOrders: OrderBatch[],
    goodTilBlock: number,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.batchCancelShortTermOrdersMsg(
      subaccount.address,
      subaccount.subaccountNumber,
      shortTermOrders,
      goodTilBlock
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      true,
      undefined,
      undefined,
      broadcastMode
    );
  }

  async batchCancelShortTermOrdersMsg(
    address: string,
    subaccountNumber: number,
    shortTermOrders: OrderBatch[],
    goodTilBlock: number
  ): Promise<EncodeObject> {
    return new Promise((resolve) => {
      const msg = this.composer.composeMsgBatchCancelShortTermOrders(
        address,
        subaccountNumber,
        shortTermOrders,
        goodTilBlock
      );
      resolve(msg);
    });
  }

  async transfer(
    subaccount: WalletSubaccountInfo,
    recipientAddress: string,
    recipientSubaccountNumber: number,
    assetId: number,
    amount: Long,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.transferMsg(
      subaccount.address,
      subaccount.subaccountNumber,
      recipientAddress,
      recipientSubaccountNumber,
      assetId,
      amount
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      false,
      undefined,
      undefined,
      broadcastMode
    );
  }

  async transferMsg(
    address: string,
    subaccountNumber: number,
    recipientAddress: string,
    recipientSubaccountNumber: number,
    assetId: number,
    amount: Long
  ): Promise<EncodeObject> {
    return new Promise((resolve) => {
      const msg = this.composer.composeMsgTransfer(
        address,
        subaccountNumber,
        recipientAddress,
        recipientSubaccountNumber,
        assetId,
        amount
      );
      resolve(msg);
    });
  }

  async deposit(
    subaccount: WalletSubaccountInfo,
    assetId: number,
    quantums: Long,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.depositMsg(
      subaccount.address,
      subaccount.subaccountNumber,
      assetId,
      quantums
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      false,
      undefined,
      undefined,
      broadcastMode
    );
  }

  async depositMsg(
    address: string,
    subaccountNumber: number,
    assetId: number,
    quantums: Long
  ): Promise<EncodeObject> {
    return new Promise((resolve) => {
      const msg = this.composer.composeMsgDepositToSubaccount(
        address,
        subaccountNumber,
        assetId,
        quantums
      );
      resolve(msg);
    });
  }

  async withdraw(
    subaccount: WalletSubaccountInfo,
    assetId: number,
    quantums: Long,
    recipient?: string,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.withdrawMsg(
      subaccount.address,
      subaccount.subaccountNumber,
      assetId,
      quantums,
      recipient
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      false,
      undefined,
      undefined,
      broadcastMode
    );
  }

  async withdrawMsg(
    address: string,
    subaccountNumber: number,
    assetId: number,
    quantums: Long,
    recipient?: string
  ): Promise<EncodeObject> {
    return new Promise((resolve) => {
      const msg = this.composer.composeMsgWithdrawFromSubaccount(
        address,
        subaccountNumber,
        assetId,
        quantums,
        recipient
      );
      resolve(msg);
    });
  }

  async sendNativeToken(
    subaccount: WalletSubaccountInfo,
    recipient: string,
    coinDenom: string,
    quantums: string,
    zeroFee = true,
    broadcastMode?: BroadcastMode
  ): TxResponsePromise {
    const msg = await this.sendNativeTokenMsg(
      subaccount.address,
      recipient,
      coinDenom,
      quantums
    );
    return this.send(
      subaccount.wallet,
      () => Promise.resolve([msg]),
      zeroFee,
      this.defaultGasPrice,
      undefined,
      broadcastMode
    );
  }

  async sendNativeTokenMsg(
    address: string,
    recipient: string,
    coinDenom: string,
    quantums: string
  ): Promise<EncodeObject> {
    if (coinDenom !== TDAI_DENOM) {
      throw new Error("Unsupported coinDenom");
    }

    return new Promise((resolve) => {
      const msg = this.composer.composeMsgSendToken(
        address,
        recipient,
        coinDenom,
        quantums
      );
      resolve(msg);
    });
  }
}
