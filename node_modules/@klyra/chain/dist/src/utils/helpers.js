"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteArrayEncoding = void 0;
exports.convertPartialTransactionOptionsToFull = convertPartialTransactionOptionsToFull;
exports.stripHexPrefix = stripHexPrefix;
exports.bigIntToBytes = bigIntToBytes;
exports.encodeJson = encodeJson;
const encoding_1 = require("@cosmjs/encoding");
const long_1 = __importDefault(require("long"));
const constants_1 = require("../constants");
/**
 * @description Either return undefined or insert default sequence value into
 * `partialTransactionOptions` if it does not exist.
 *
 * @returns undefined or full TransactionOptions.
 */
function convertPartialTransactionOptionsToFull(partialTransactionOptions) {
    if (partialTransactionOptions === undefined) {
        return undefined;
    }
    return {
        sequence: constants_1.DEFAULT_SEQUENCE,
        ...partialTransactionOptions,
    };
}
/**
 * @description Strip '0x' prefix from input string. If there is no '0x' prefix, return the original
 * input.
 *
 * @returns input without '0x' prefix or original input if no prefix.
 */
function stripHexPrefix(input) {
    if (input.startsWith("0x")) {
        return input.slice(2);
    }
    return input;
}
function toBigInt(u) {
    if (u.length <= 1) {
        return BigInt(0);
    }
    // eslint-disable-next-line no-bitwise -- bitwise operations are needed here
    const negated = (u[0] & 1) === 1;
    const hex = Array.from(u.slice(1))
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
    const abs = BigInt(`0x${hex}`);
    return negated ? -abs : abs;
}
function bigIntToBytes(value) {
    const absoluteValue = value < 0 ? value * BigInt(-1) : value;
    const nonPaddedHexValue = absoluteValue.toString(16);
    const paddedHexValue = nonPaddedHexValue.length % 2 === 0
        ? nonPaddedHexValue
        : `0${nonPaddedHexValue}`;
    const numberBytes = new Uint8Array(paddedHexValue.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    const signedBytes = new Uint8Array([value < 0 ? 3 : 2, ...numberBytes]);
    return signedBytes;
}
var ByteArrayEncoding;
(function (ByteArrayEncoding) {
    ByteArrayEncoding["HEX"] = "hex";
    ByteArrayEncoding["BIGINT"] = "bigint";
})(ByteArrayEncoding || (exports.ByteArrayEncoding = ByteArrayEncoding = {}));
/* eslint-disable @typescript-eslint/no-unsafe-member-access -- any and unsafe member access needed for JSON replacer function */
/* eslint-disable @typescript-eslint/no-unsafe-argument -- unsafe argument needed for JSON replacer function */
/* eslint-disable @typescript-eslint/no-unsafe-return -- any is needed for JSON replacer function */
// TODO: Add better type safety for this function
function encodeJson(object, byteArrayEncoding = ByteArrayEncoding.HEX) {
    return JSON.stringify(object, function replacer(_key, value) {
        // Even though we set the an UInt8Array as the value,
        // it comes in here as an object with UInt8Array as the buffer property.
        if (typeof value === "bigint") {
            return value.toString();
        }
        if (value instanceof long_1.default) {
            return value.toString();
        }
        if ((value === null || value === void 0 ? void 0 : value.buffer) instanceof Uint8Array) {
            if (byteArrayEncoding === ByteArrayEncoding.HEX) {
                return (0, encoding_1.toHex)(value.buffer);
            }
            return toBigInt(value.buffer).toString();
        }
        else if (value instanceof Uint8Array) {
            if (byteArrayEncoding === ByteArrayEncoding.HEX) {
                return (0, encoding_1.toHex)(value);
            }
            return toBigInt(value).toString();
        }
        return value;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQWNBLHdGQVdDO0FBUUQsd0NBTUM7QUFlRCxzQ0FZQztBQVdELGdDQTBCQztBQXZHRCwrQ0FBeUM7QUFDekMsZ0RBQXdCO0FBQ3hCLDRDQUFnRDtBQU1oRDs7Ozs7R0FLRztBQUNILFNBQWdCLHNDQUFzQyxDQUNwRCx5QkFBcUQ7SUFFckQsSUFBSSx5QkFBeUIsS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUM1QyxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsT0FBTztRQUNMLFFBQVEsRUFBRSw0QkFBZ0I7UUFDMUIsR0FBRyx5QkFBeUI7S0FDN0IsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGNBQWMsQ0FBQyxLQUFhO0lBQzFDLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQzNCLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUMsQ0FBYTtJQUM3QixJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDbEIsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUNELDRFQUE0RTtJQUM1RSxNQUFNLE9BQU8sR0FBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0MsTUFBTSxHQUFHLEdBQVcsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3ZDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQzNDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNaLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDL0IsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDOUIsQ0FBQztBQUVELFNBQWdCLGFBQWEsQ0FBQyxLQUFhO0lBQ3pDLE1BQU0sYUFBYSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQzdELE1BQU0saUJBQWlCLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNyRCxNQUFNLGNBQWMsR0FDbEIsaUJBQWlCLENBQUMsTUFBTSxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQ2hDLENBQUMsQ0FBQyxpQkFBaUI7UUFDbkIsQ0FBQyxDQUFDLElBQUksaUJBQWlCLEVBQUUsQ0FBQztJQUM5QixNQUFNLFdBQVcsR0FBRyxJQUFJLFVBQVUsQ0FDaEMsY0FBYyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FDbkUsQ0FBQztJQUNGLE1BQU0sV0FBVyxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFFRCxJQUFZLGlCQUdYO0FBSEQsV0FBWSxpQkFBaUI7SUFDM0IsZ0NBQVcsQ0FBQTtJQUNYLHNDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFIVyxpQkFBaUIsaUNBQWpCLGlCQUFpQixRQUc1QjtBQUVELGlJQUFpSTtBQUNqSSwrR0FBK0c7QUFDL0csb0dBQW9HO0FBQ3BHLGlEQUFpRDtBQUNqRCxTQUFnQixVQUFVLENBQ3hCLE1BQWdDLEVBQ2hDLG9CQUF1QyxpQkFBaUIsQ0FBQyxHQUFHO0lBRTVELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUs7UUFDekQscURBQXFEO1FBQ3JELHdFQUF3RTtRQUN4RSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQzlCLE9BQU8sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzFCLENBQUM7UUFDRCxJQUFJLEtBQUssWUFBWSxjQUFJLEVBQUUsQ0FBQztZQUMxQixPQUFPLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMxQixDQUFDO1FBQ0QsSUFBSSxDQUFBLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxNQUFNLGFBQVksVUFBVSxFQUFFLENBQUM7WUFDeEMsSUFBSSxpQkFBaUIsS0FBSyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDaEQsT0FBTyxJQUFBLGdCQUFLLEVBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdCLENBQUM7WUFDRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDM0MsQ0FBQzthQUFNLElBQUksS0FBSyxZQUFZLFVBQVUsRUFBRSxDQUFDO1lBQ3ZDLElBQUksaUJBQWlCLEtBQUssaUJBQWlCLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2hELE9BQU8sSUFBQSxnQkFBSyxFQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RCLENBQUM7WUFDRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNwQyxDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMifQ==