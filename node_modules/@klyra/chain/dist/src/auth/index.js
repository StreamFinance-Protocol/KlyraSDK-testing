"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountFromUUID = getAccountFromUUID;
exports.getAccountFromCredentials = getAccountFromCredentials;
exports.getAccountFromSignedMessage = getAccountFromSignedMessage;
const bip32_1 = require("@scure/bip32");
const bip39_1 = require("@scure/bip39");
const keccak_1 = require("ethereum-cryptography/keccak");
const english_1 = require("@scure/bip39/wordlists/english");
const helpers_1 = require("../utils/helpers");
const local_wallet_1 = require("../lib/local-wallet");
const constants_1 = require("../constants");
async function getAccountFromUUID(uuid) {
    let buffer = new TextEncoder().encode(uuid);
    if (buffer.length < 65) {
        const padding = new Uint8Array(65 - buffer.length);
        buffer = new Uint8Array([...buffer, ...padding]);
    }
    if (buffer.length > 65) {
        buffer = buffer.slice(0, 65);
    }
    const adjustedUUID = Array.from(buffer)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
    const { mnemonic, privateKey, publicKey } = getHDKeyFromMessage(adjustedUUID);
    // Create wallet from mnemonic
    const wallet = await local_wallet_1.LocalWallet.fromMnemonic(mnemonic, constants_1.BECH32_PREFIX);
    return {
        wallet,
        mnemonic,
        privateKey,
        publicKey,
    };
}
async function getAccountFromCredentials(username, pwd) {
    const usernameHash = (0, keccak_1.keccak256)(new TextEncoder().encode(username));
    const pwdHash = (0, keccak_1.keccak256)(new TextEncoder().encode(pwd));
    const concatenatedHashes = new Uint8Array([
        ...usernameHash,
        ...pwdHash,
        0x01,
    ]);
    const { mnemonic, privateKey, publicKey } = getHDKeyFromMessage(Array.from(concatenatedHashes)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join(""));
    const wallet = await local_wallet_1.LocalWallet.fromMnemonic(mnemonic, constants_1.BECH32_PREFIX);
    return {
        wallet,
        mnemonic,
        privateKey,
        publicKey,
    };
}
async function getAccountFromSignedMessage(signedMessage) {
    const { mnemonic, privateKey, publicKey } = getHDKeyFromMessage(signedMessage);
    const wallet = await local_wallet_1.LocalWallet.fromMnemonic(mnemonic, constants_1.BECH32_PREFIX);
    return {
        wallet,
        mnemonic,
        privateKey,
        publicKey,
    };
}
function getHDKeyFromMessage(message) {
    var _a, _b;
    const buffer = new Uint8Array((_b = (_a = (0, helpers_1.stripHexPrefix)(message)
        .match(/.{1,2}/g)) === null || _a === void 0 ? void 0 : _a.map((byte) => parseInt(byte, 16))) !== null && _b !== void 0 ? _b : []);
    if (buffer.length !== 65) {
        throw new Error("Message must be 65 bytes");
    }
    // Remove the 'v' value by taking only the first 64 bytes of the message
    const rsValues = buffer.slice(0, 64);
    // Hash the 'r' and 's' values down to 32 bytes (256 bits) using Keccak-256
    const entropy = (0, keccak_1.keccak256)(rsValues);
    return exportMnemonicAndPrivateKey(entropy);
}
function exportMnemonicAndPrivateKey(entropy, path = "m/44'/118'/0'/0/0") {
    const mnemonic = (0, bip39_1.entropyToMnemonic)(entropy, english_1.wordlist);
    const { privateKey, publicKey } = deriveHDKeyFromMnemonic(mnemonic, path);
    return {
        mnemonic,
        privateKey,
        publicKey,
    };
}
function deriveHDKeyFromMnemonic(mnemonic, path) {
    const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
    const hdkey = bip32_1.HDKey.fromMasterSeed(seed);
    const derivedHdkey = hdkey.derive(path);
    if (!hdkey.privateKey) {
        throw new Error("null hd key");
    }
    return {
        privateKey: derivedHdkey.privateKey,
        publicKey: derivedHdkey.publicKey,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXV0aC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQWFBLGdEQStCQztBQUVELDhEQWdDQztBQUVELGtFQW1CQztBQW5HRCx3Q0FBcUM7QUFDckMsd0NBQXFFO0FBQ3JFLHlEQUF5RDtBQUN6RCw0REFBMEQ7QUFDMUQsOENBQWtEO0FBQ2xELHNEQUFrRDtBQUNsRCw0Q0FBNkM7QUFPdEMsS0FBSyxVQUFVLGtCQUFrQixDQUFDLElBQVk7SUFNbkQsSUFBSSxNQUFNLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFNUMsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkQsTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFDdkIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNwQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUMzQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFWixNQUFNLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsR0FB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