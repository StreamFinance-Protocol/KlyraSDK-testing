"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const order_1 = require("@klyra/proto/src/codegen/klyraprotocol/clob/order");
const long_1 = __importDefault(require("long"));
const ethers_1 = require("ethers");
const indexer_1 = __importDefault(require("../indexer"));
const node_1 = __importDefault(require("../node"));
const types_1 = require("../types");
const chain_helpers_1 = require("../utils/chain-helpers");
const constants_1 = require("../constants");
const errors_1 = require("../lib/errors");
const validation_1 = require("../lib/validation");
class ChainClient {
    constructor(config) {
        this.isInitialized = false;
        this.indexerClient = new indexer_1.default({
            ...config.indexer,
        });
        this.nodeClient = new node_1.default({
            ...config.node,
        });
    }
    async initialize() {
        await this.nodeClient.initialize();
        this.isInitialized = true;
    }
    /**
     * @description Sign a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Signature.
     */
    async sign(wallet, messaging, zeroFee, gasPrice, memo, account) {
        return this.nodeClient.post.sign(wallet, messaging, zeroFee, gasPrice, memo, account);
    }
    /**
     * @description Send a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Transaction Hash.
     */
    async send(wallet, messaging, zeroFee, gasPrice, memo, broadcastMode, account) {
        return this.nodeClient.post.send(wallet, messaging, zeroFee, gasPrice, memo, broadcastMode, account);
    }
    /**
     * @description Send a signed transaction.
     *
     * @param signedTransaction The signed transaction to send.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Transaction Hash.
     */
    async sendSignedTransaction(signedTransaction) {
        return this.nodeClient.post.sendSignedTransaction(signedTransaction);
    }
    /**
     * @description Simulate a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * To send multiple messages with gas estimate:
     * 1. Client is responsible for creating the messages.
     * 2. Call simulate() to get the gas estimate.
     * 3. Call send() to send the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The gas estimate.
     */
    async simulate(wallet, messaging, gasPrice, memo, account) {
        return this.nodeClient.post.simulate(wallet, messaging, gasPrice, memo, account);
    }
    /**
     * @description Calculate the goodTilBlock value for a SHORT_TERM order
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The goodTilBlock value
     */
    async calculateGoodTilBlock(orderFlags, currentHeight, goodTilBlock) {
        if (orderFlags === types_1.OrderFlags.SHORT_TERM) {
            if (goodTilBlock) {
                return Promise.resolve(goodTilBlock);
            }
            const height = currentHeight !== null && currentHeight !== void 0 ? currentHeight : (await this.nodeClient.get.latestBlockHeight());
            return height + constants_1.SHORT_BLOCK_FORWARD;
        }
        return Promise.resolve(0);
    }
    /**
     * @description Validate the goodTilBlock value for a SHORT_TERM order
     *
     * @param goodTilBlock Number of blocks from the current block height the order will
     * be valid for.
     *
     * @throws UserError if the goodTilBlock value is not valid given latest block height and
     * SHORT_BLOCK_WINDOW.
     */
    async validateGoodTilBlock(goodTilBlock) {
        const height = await this.nodeClient.get.latestBlockHeight();
        const nextValidBlockHeight = height + 1;
        const lowerBound = nextValidBlockHeight;
        const upperBound = nextValidBlockHeight + constants_1.SHORT_BLOCK_WINDOW;
        if (goodTilBlock < lowerBound || goodTilBlock > upperBound) {
            throw new errors_1.UserError(`Invalid Short-Term order GoodTilBlock.
        Should be greater-than-or-equal-to ${lowerBound} and less-than-or-equal-to ${upperBound}.
        Provided good til block: ${goodTilBlock}`);
        }
    }
    /**
     * @description Calculate the goodTilBlockTime value for a LONG_TERM order
     * the calling function is responsible for creating the messages.
     *
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The goodTilBlockTime value
     */
    calculateGoodTilBlockTime(goodTilTimeInSeconds) {
        const now = new Date();
        const millisecondsPerSecond = 1000;
        const interval = goodTilTimeInSeconds * millisecondsPerSecond;
        const future = new Date(now.valueOf() + interval);
        return Math.round(future.getTime() / 1000);
    }
    /**
     * @description Place a short term order with human readable input.
     *
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilBlock The goodTilBlock of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async placeShortTermOrder(subaccount, marketId, side, price, size, clientId, goodTilBlock, timeInForce, reduceOnly, routerFeePpm, routerSubaccount, memo) {
        const msgs = new Promise((resolve, reject) => {
            const msg = this.placeShortTermOrderMessage(subaccount, marketId, side, price, size, clientId, goodTilBlock, timeInForce, reduceOnly, routerFeePpm, routerSubaccount);
            msg
                .then((it) => {
                resolve([it]);
            })
                .catch((err) => {
                reject(err instanceof Error ? err : new Error(String(err)));
            });
        });
        const account = this.nodeClient.post.account(subaccount.address, undefined);
        return this.send(subaccount.wallet, () => msgs, true, undefined, memo, undefined, () => account);
    }
    /**
     * @description Place an order with human readable input.
     *
     * Only MARKET and LIMIT types are supported right now
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order on.
     * @param marketId The market to place the order on.
     * @param type The type of order to place.
     * @param side The side of the order to place.
     * @param price The price of the order to place.
     * @param size The size of the order to place.
     * @param clientId The client id of the order to place.
     * @param timeInForce The time in force of the order to place.
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
     * @param execution The execution of the order to place.
     * @param postOnly The postOnly of the order to place.
     * @param reduceOnly The reduceOnly of the order to place.
     * @param triggerPrice The trigger price of conditional orders.
     * @param marketInfo optional market information for calculating quantums and subticks.
     *        This can be constructed from Indexer API. If set to null, additional round
     *        trip to Indexer API will be made.
     * @param currentHeight Current block height. This can be obtained from nodeClient.
     *        If set to null, additional round trip to nodeClient will be made.
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async placeOrder(subaccount, marketId, type, side, price, size, clientId, timeInForce, goodTilTimeInSeconds, routerFeePpm, routerSubaccount, execution, postOnly, reduceOnly, triggerPrice, marketInfo, currentHeight, goodTilBlock, memo) {
        const msgs = new Promise((resolve, reject) => {
            const msg = this.placeOrderMessage(subaccount, marketId, type, side, price, size, clientId, timeInForce, goodTilTimeInSeconds, routerFeePpm, routerSubaccount, execution, postOnly, reduceOnly, triggerPrice, marketInfo, currentHeight, goodTilBlock);
            msg
                .then((it) => {
                resolve([it]);
            })
                .catch((err) => {
                reject(err instanceof Error ? err : new Error(String(err)));
            });
        });
        const orderFlags = (0, chain_helpers_1.calculateOrderFlags)(type, timeInForce);
        const account = this.nodeClient.post.account(subaccount.address, orderFlags);
        return this.send(subaccount.wallet, () => msgs, true, undefined, memo, undefined, () => account);
    }
    /**
     * @description Calculate and create the place order message
     *
     * Only MARKET and LIMIT types are supported right now
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param type The type of order to place
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place
     * @param routerFeePpm The ppm fee that goes to the exchange that routed the order
     * @param routerSubaccount The subaccount of the exchange that routed the order
     * @param execution The execution of the order to place
     * @param postOnly The postOnly of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message to be passed into the protocol
     */
    async placeOrderMessage(subaccount, marketId, type, side, price, 
    // trigger_price: number,   // not used for MARKET and LIMIT
    size, clientId, timeInForce, goodTilTimeInSeconds, routerFeePpm, routerSubaccount, execution, postOnly, reduceOnly, triggerPrice, marketInfo, currentHeight, goodTilBlock) {
        var _a, _b;
        const orderFlags = (0, chain_helpers_1.calculateOrderFlags)(type, timeInForce);
        const result = await Promise.all([
            this.calculateGoodTilBlock(orderFlags, currentHeight, goodTilBlock),
            this.retrieveMarketInfo(marketId, marketInfo),
        ]);
        const desiredGoodTilBlock = result[0];
        const clobPairId = result[1].clobPairId;
        const atomicResolution = result[1].atomicResolution;
        const stepBaseQuantums = result[1].stepBaseQuantums;
        const quantumConversionExponent = result[1].quantumConversionExponent;
        const subticksPerTick = result[1].subticksPerTick;
        const orderSide = (0, chain_helpers_1.calculateSide)(side);
        const quantums = (0, chain_helpers_1.calculateQuantums)(size, atomicResolution, stepBaseQuantums);
        const subticks = (0, chain_helpers_1.calculateSubticks)(price, atomicResolution, quantumConversionExponent, subticksPerTick);
        const orderTimeInForce = (0, chain_helpers_1.calculateTimeInForce)(type, timeInForce, execution, postOnly);
        let goodTilBlockTime = 0;
        if (orderFlags === types_1.OrderFlags.LONG_TERM ||
            orderFlags === types_1.OrderFlags.CONDITIONAL) {
            if (typeof goodTilTimeInSeconds === "undefined") {
                throw new Error("goodTilTimeInSeconds must be set for LONG_TERM or CONDITIONAL order");
            }
            else {
                goodTilBlockTime = this.calculateGoodTilBlockTime(goodTilTimeInSeconds);
            }
        }
        const clientMetadata = (0, chain_helpers_1.calculateClientMetadata)(type);
        const conditionalType = (0, chain_helpers_1.calculateConditionType)(type);
        const conditionalOrderTriggerSubticks = (0, chain_helpers_1.calculateConditionalOrderTriggerSubticks)(type, atomicResolution, quantumConversionExponent, subticksPerTick, triggerPrice);
        if (routerFeePpm && !routerSubaccount) {
            throw new Error("Cannot have router fee without specifying the router subaccount");
        }
        return this.nodeClient.post.composer.composeMsgPlaceOrder(subaccount.address, subaccount.subaccountNumber, clientId, clobPairId, orderFlags, desiredGoodTilBlock, goodTilBlockTime, orderSide, quantums, subticks, routerFeePpm !== null && routerFeePpm !== void 0 ? routerFeePpm : 0, (_a = routerSubaccount === null || routerSubaccount === void 0 ? void 0 : routerSubaccount.address) !== null && _a !== void 0 ? _a : "", (_b = routerSubaccount === null || routerSubaccount === void 0 ? void 0 : routerSubaccount.subaccountNumber) !== null && _b !== void 0 ? _b : 0, orderTimeInForce, reduceOnly !== null && reduceOnly !== void 0 ? reduceOnly : false, clientMetadata, conditionalType, conditionalOrderTriggerSubticks);
    }
    async retrieveMarketInfo(marketId, marketInfo) {
        if (marketInfo) {
            return Promise.resolve(marketInfo);
        }
        const market = await this.indexerClient.markets.getPerpetualMarket(marketId);
        const clobPairId = market.clobPairId;
        const atomicResolution = market.atomicResolution;
        const stepBaseQuantums = market.stepBaseQuantums;
        const quantumConversionExponent = market.quantumConversionExponent;
        const subticksPerTick = market.subticksPerTick;
        return {
            clobPairId: Number(clobPairId),
            atomicResolution: Number(atomicResolution),
            stepBaseQuantums: Number(stepBaseQuantums),
            quantumConversionExponent: Number(quantumConversionExponent),
            subticksPerTick: Number(subticksPerTick),
        };
    }
    /**
     * @description Calculate and create the short term place order message
     *
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilBlock The goodTilBlock of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message to be passed into the protocol
     */
    async placeShortTermOrderMessage(subaccount, marketId, side, price, size, clientId, goodTilBlock, timeInForce, reduceOnly, routerFeePpm, routerSubaccount) {
        var _a, _b;
        await this.validateGoodTilBlock(goodTilBlock);
        const market = await this.indexerClient.markets.getPerpetualMarket(marketId);
        const clobPairId = market.clobPairId;
        const atomicResolution = market.atomicResolution;
        const stepBaseQuantums = market.stepBaseQuantums;
        const quantumConversionExponent = market.quantumConversionExponent;
        const subticksPerTick = market.subticksPerTick;
        const orderSide = (0, chain_helpers_1.calculateSide)(side);
        const quantums = (0, chain_helpers_1.calculateQuantums)(size, Number(atomicResolution), Number(stepBaseQuantums));
        const subticks = (0, chain_helpers_1.calculateSubticks)(price, atomicResolution, Number(quantumConversionExponent), Number(subticksPerTick));
        const orderFlags = types_1.OrderFlags.SHORT_TERM;
        if (routerFeePpm && !routerSubaccount) {
            throw new Error("Cannot have router fee without specifying the router subaccount");
        }
        return this.nodeClient.post.composer.composeMsgPlaceOrder(subaccount.address, subaccount.subaccountNumber, clientId, Number(clobPairId), orderFlags, goodTilBlock, 0, // Short term orders use goodTilBlock.
        orderSide, quantums, subticks, routerFeePpm !== null && routerFeePpm !== void 0 ? routerFeePpm : 0, (_a = routerSubaccount === null || routerSubaccount === void 0 ? void 0 : routerSubaccount.address) !== null && _a !== void 0 ? _a : "", (_b = routerSubaccount === null || routerSubaccount === void 0 ? void 0 : routerSubaccount.subaccountNumber) !== null && _b !== void 0 ? _b : 0, timeInForce, reduceOnly, 0, // Client metadata is 0 for short term orders.
        order_1.Order_ConditionType.CONDITION_TYPE_UNSPECIFIED, // Short term orders cannot be conditional.
        long_1.default.fromInt(0) // Short term orders cannot be conditional.
        );
    }
    /**
     * @description Cancel an order with order information from web socket or REST.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param clientId The client id of the order to cancel
     * @param orderFlags The order flags of the order to cancel
     * @param clobPairId The clob pair id of the order to cancel
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async cancelRawOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime) {
        return this.nodeClient.post.cancelOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime);
    }
    /**
     * @description Cancel an order with human readable input.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param clientId The client id of the order to cancel
     * @param orderFlags The order flags of the order to cancel
     * @param marketId The market to cancel the order on
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async cancelOrder(subaccount, clientId, orderFlags, ticker, goodTilBlock, goodTilTimeInSeconds) {
        const market = await this.indexerClient.markets.getPerpetualMarket(ticker);
        const clobPairId = market.clobPairId;
        if (!(0, validation_1.verifyOrderFlags)(orderFlags)) {
            throw new Error(`Invalid order flags: ${orderFlags}`);
        }
        let goodTilBlockTime;
        if ((0, validation_1.isStatefulOrder)(orderFlags)) {
            if (goodTilTimeInSeconds === undefined || goodTilTimeInSeconds === 0) {
                throw new Error("goodTilTimeInSeconds must be set for LONG_TERM or CONDITIONAL order");
            }
            if (goodTilBlock !== 0) {
                throw new Error("goodTilBlock should be zero since LONG_TERM or CONDITIONAL orders " +
                    "use goodTilTimeInSeconds instead of goodTilBlock.");
            }
            goodTilBlockTime = this.calculateGoodTilBlockTime(goodTilTimeInSeconds);
        }
        else {
            if (goodTilBlock === undefined || goodTilBlock === 0) {
                throw new Error("goodTilBlock must be non-zero for SHORT_TERM orders");
            }
            if (goodTilTimeInSeconds !== undefined && goodTilTimeInSeconds !== 0) {
                throw new Error("goodTilTimeInSeconds should be zero since SHORT_TERM orders use goodTilBlock instead of goodTilTimeInSeconds.");
            }
        }
        return this.nodeClient.post.cancelOrder(subaccount, clientId, orderFlags, Number(clobPairId), goodTilBlock, goodTilBlockTime);
    }
    /**
     * @description Batch cancel short term orders using marketId to clobPairId translation.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param shortTermOrders The list of short term order batches to cancel with marketId
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @returns The transaction hash.
     */
    async batchCancelShortTermOrdersWithMarketId(subaccount, shortTermOrders, goodTilBlock, broadcastMode) {
        const orderBatches = await Promise.all(shortTermOrders.map(async ({ marketId, clobPairId, clientIds }) => ({
            clobPairId: Number(clobPairId !== null && clobPairId !== void 0 ? clobPairId : (await this.indexerClient.markets.getPerpetualMarket(marketId))
                .clobPairId),
            clientIds,
        })));
        return this.nodeClient.post.batchCancelShortTermOrders(subaccount, orderBatches, goodTilBlock, broadcastMode);
    }
    /**
     * @description Batch cancel short term orders using clobPairId.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param shortTermOrders The list of short term order batches to cancel with clobPairId
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @returns The transaction hash.
     */
    async batchCancelShortTermOrdersWithClobPairId(subaccount, shortTermOrders, goodTilBlock, broadcastMode) {
        return this.nodeClient.post.batchCancelShortTermOrders(subaccount, shortTermOrders, goodTilBlock, broadcastMode);
    }
    /**
     * @description Transfer from a subaccount to another subaccount
     *
     * @param subaccount The subaccount to transfer from
     * @param recipientAddress The recipient address
     * @param recipientSubaccountNumber The recipient subaccount number
     * @param amount The amount to transfer
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async transferToSubaccount(subaccount, recipientAddress, recipientSubaccountNumber, amount, memo, broadcastMode) {
        const msgs = new Promise((resolve) => {
            const msg = this.transferToSubaccountMessage(subaccount, recipientAddress, recipientSubaccountNumber, amount);
            resolve([msg]);
        });
        return this.send(subaccount.wallet, () => msgs, false, undefined, memo, broadcastMode !== null && broadcastMode !== void 0 ? broadcastMode : tendermint_rpc_1.Method.BroadcastTxCommit);
    }
    /**
     * @description Create message to transfer from a subaccount to another subaccount
     *
     * @param subaccount The subaccount to transfer from
     * @param recipientAddress The recipient address
     * @param recipientSubaccountNumber The recipient subaccount number
     * @param amount The amount to transfer
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    transferToSubaccountMessage(subaccount, recipientAddress, recipientSubaccountNumber, amount) {
        const nodeClient = this.nodeClient;
        if (typeof nodeClient === "undefined") {
            throw new Error("nodeClient not set");
        }
        const quantums = (0, ethers_1.parseUnits)(amount, constants_1.TDAI_DECIMALS);
        if (quantums > BigInt(long_1.default.MAX_VALUE.toString())) {
            throw new Error("amount to large");
        }
        if (quantums < 0) {
            throw new Error("amount must be positive");
        }
        return this.nodeClient.post.composer.composeMsgTransfer(subaccount.address, subaccount.subaccountNumber, recipientAddress, recipientSubaccountNumber, 0, long_1.default.fromString(quantums.toString()));
    }
    /**
     * @description Deposit from wallet to subaccount
     *
     * @param subaccount The subaccount to deposit to
     * @param amount The amount to deposit
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    async depositToSubaccount(subaccount, amount, memo) {
        const msgs = new Promise((resolve) => {
            const msg = this.depositToSubaccountMessage(subaccount, amount);
            resolve([msg]);
        });
        return this.nodeClient.post.send(subaccount.wallet, () => msgs, false, undefined, memo);
    }
    /**
     * @description Create message to deposit from wallet to subaccount
     *
     * @param subaccount The subaccount to deposit to
     * @param amount The amount to deposit
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    depositToSubaccountMessage(subaccount, amount) {
        const nodeClient = this.nodeClient;
        if (typeof nodeClient === "undefined") {
            throw new Error("nodeClient not set");
        }
        const quantums = (0, ethers_1.parseUnits)(amount, constants_1.TDAI_DECIMALS);
        if (quantums > BigInt(long_1.default.MAX_VALUE.toString())) {
            throw new Error("amount to large");
        }
        if (quantums < 0) {
            throw new Error("amount must be positive");
        }
        return this.nodeClient.post.composer.composeMsgDepositToSubaccount(subaccount.address, subaccount.subaccountNumber, 0, long_1.default.fromString(quantums.toString()));
    }
    /**
     * @description Withdraw from subaccount to wallet
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address, default to subaccount address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash
     */
    async withdrawFromSubaccount(subaccount, amount, recipient, memo) {
        const msgs = new Promise((resolve) => {
            const msg = this.withdrawFromSubaccountMessage(subaccount, amount, recipient);
            resolve([msg]);
        });
        return this.send(subaccount.wallet, () => msgs, false, undefined, memo);
    }
    /**
     * @description Create message to withdraw from subaccount to wallet
     * with human readable input.
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    withdrawFromSubaccountMessage(subaccount, amount, recipient) {
        const nodeClient = this.nodeClient;
        if (typeof nodeClient === "undefined") {
            throw new Error("nodeClient not set");
        }
        const quantums = (0, ethers_1.parseUnits)(amount, constants_1.TDAI_DECIMALS);
        if (quantums > BigInt(long_1.default.MAX_VALUE.toString())) {
            throw new Error("amount to large");
        }
        if (quantums < 0) {
            throw new Error("amount must be positive");
        }
        return this.nodeClient.post.composer.composeMsgWithdrawFromSubaccount(subaccount.address, subaccount.subaccountNumber, 0, long_1.default.fromString(quantums.toString()), recipient);
    }
    async signPlaceOrder(subaccount, marketId, type, side, price, size, clientId, timeInForce, goodTilTimeInSeconds, execution, postOnly, reduceOnly, routerFeePpm, routerSubaccount) {
        const msgs = new Promise((resolve) => {
            const msg = this.placeOrderMessage(subaccount, marketId, type, side, price, 
            // trigger_price: number,   // not used for MARKET and LIMIT
            size, clientId, timeInForce, goodTilTimeInSeconds, routerFeePpm, routerSubaccount, execution, postOnly, reduceOnly);
            msg
                .then((it) => {
                resolve([it]);
            })
                .catch((err) => {
                throw err;
            });
        });
        const signature = await this.sign(subaccount.wallet, () => msgs, true);
        return btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(signature))));
    }
    async signCancelOrder(subaccount, clientId, orderFlags, clobPairId, goodTilBlock, goodTilBlockTime) {
        const msgs = new Promise((resolve) => {
            const msg = this.nodeClient.post.composer.composeMsgCancelOrder(subaccount.address, subaccount.subaccountNumber, clientId, clobPairId, orderFlags, goodTilBlock, goodTilBlockTime);
            resolve([msg]);
        });
        const signature = await this.sign(subaccount.wallet, () => msgs, true);
        return btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(signature))));
    }
}
exports.default = ChainClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2xpZW50L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBUUEsMkRBQWdEO0FBQ2hELDZFQUcyRDtBQUMzRCxnREFBd0I7QUFDeEIsbUNBQW9DO0FBQ3BDLHlEQUF1QztBQUV2QyxtREFBaUM7QUFDakMsb0NBTWtCO0FBS2xCLDBEQVNnQztBQUVoQyw0Q0FJc0I7QUFDdEIsMENBQTBDO0FBQzFDLGtEQUFzRTtBQXFCdEUsTUFBcUIsV0FBVztJQUs5QixZQUFZLE1BQXlCO1FBSjlCLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBSzNCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxpQkFBYSxDQUFDO1lBQ3JDLEdBQUcsTUFBTSxDQUFDLE9BQU87U0FDbEIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGNBQVUsQ0FBQztZQUMvQixHQUFHLE1BQU0sQ0FBQyxJQUFJO1NBQ2YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLEtBQUssQ0FBQyxVQUFVO1FBQ3JCLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILEtBQUssQ0FBQyxJQUFJLENBQ1IsTUFBbUIsRUFDbkIsU0FBd0MsRUFDeEMsT0FBZ0IsRUFDaEIsUUFBbUIsRUFDbkIsSUFBYSxFQUNiLE9BQWdDO1FBRWhDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUM5QixNQUFNLEVBQ04sU0FBUyxFQUNULE9BQU8sRUFDUCxRQUFRLEVBQ1IsSUFBSSxFQUNKLE9BQU8sQ0FDUixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsSUFBSSxDQUNSLE1BQW1CLEVBQ25CLFNBQXdD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