import { type Account, type GasPrice, type StdFee } from "@cosmjs/stargate";
import { type EncodeObject } from "@cosmjs/proto-signing";
import { type OrderExecution, type OrderSide, type OrderTimeInForce, type OrderType } from "@klyra/shared";
import { type Order_TimeInForce } from "@klyra/proto/src/codegen/klyraprotocol/clob/order";
import IndexerClient from "../indexer";
import { type LocalWallet } from "../lib/local-wallet";
import NodeClient from "../node";
import { type BroadcastMode, type IndexerClientConfig, type NodeClientConfig, OrderFlags, type TxResponsePromise } from "../types";
import { type WalletSubaccountInfo, type SubaccountInfo } from "../lib/subaccount";
import { type OrderBatch } from "../lib/proto-includes";
interface ChainClientConfig {
    node: NodeClientConfig;
    indexer: IndexerClientConfig;
}
export interface MarketInfo {
    clobPairId: number;
    atomicResolution: number;
    stepBaseQuantums: number;
    quantumConversionExponent: number;
    subticksPerTick: number;
}
interface OrderBatchWithMarketId {
    marketId: string;
    clobPairId?: number;
    clientIds: number[];
}
export default class ChainClient {
    isInitialized: boolean;
    indexerClient: IndexerClient;
    nodeClient: NodeClient;
    constructor(config: ChainClientConfig);
    initialize(): Promise<void>;
    /**
     * @description Sign a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Signature.
     */
    sign(wallet: LocalWallet, messaging: () => Promise<EncodeObject[]>, zeroFee: boolean, gasPrice?: GasPrice, memo?: string, account?: () => Promise<Account>): Promise<Uint8Array>;
    /**
     * @description Send a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Transaction Hash.
     */
    send(wallet: LocalWallet, messaging: () => Promise<EncodeObject[]>, zeroFee: boolean, gasPrice?: GasPrice, memo?: string, broadcastMode?: BroadcastMode, account?: () => Promise<Account>): TxResponsePromise;
    /**
     * @description Send a signed transaction.
     *
     * @param signedTransaction The signed transaction to send.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Transaction Hash.
     */
    sendSignedTransaction(signedTransaction: Uint8Array): TxResponsePromise;
    /**
     * @description Simulate a list of messages with a wallet.
     * the calling function is responsible for creating the messages.
     *
     * To send multiple messages with gas estimate:
     * 1. Client is responsible for creating the messages.
     * 2. Call simulate() to get the gas estimate.
     * 3. Call send() to send the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The gas estimate.
     */
    simulate(wallet: LocalWallet, messaging: () => Promise<EncodeObject[]>, gasPrice?: GasPrice, memo?: string, account?: () => Promise<Account>): Promise<StdFee>;
    /**
     * @description Calculate the goodTilBlock value for a SHORT_TERM order
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The goodTilBlock value
     */
    private calculateGoodTilBlock;
    /**
     * @description Validate the goodTilBlock value for a SHORT_TERM order
     *
     * @param goodTilBlock Number of blocks from the current block height the order will
     * be valid for.
     *
     * @throws UserError if the goodTilBlock value is not valid given latest block height and
     * SHORT_BLOCK_WINDOW.
     */
    private validateGoodTilBlock;
    /**
     * @description Calculate the goodTilBlockTime value for a LONG_TERM order
     * the calling function is responsible for creating the messages.
     *
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The goodTilBlockTime value
     */
    private calculateGoodTilBlockTime;
    /**
     * @description Place a short term order with human readable input.
     *
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilBlock The goodTilBlock of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    placeShortTermOrder(subaccount: WalletSubaccountInfo, marketId: string, side: OrderSide, price: number, size: number, clientId: number, goodTilBlock: number, timeInForce: Order_TimeInForce, reduceOnly: boolean, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, memo?: string): TxResponsePromise;
    /**
     * @description Place an order with human readable input.
     *
     * Only MARKET and LIMIT types are supported right now
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order on.
     * @param marketId The market to place the order on.
     * @param type The type of order to place.
     * @param side The side of the order to place.
     * @param price The price of the order to place.
     * @param size The size of the order to place.
     * @param clientId The client id of the order to place.
     * @param timeInForce The time in force of the order to place.
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place.
     * @param execution The execution of the order to place.
     * @param postOnly The postOnly of the order to place.
     * @param reduceOnly The reduceOnly of the order to place.
     * @param triggerPrice The trigger price of conditional orders.
     * @param marketInfo optional market information for calculating quantums and subticks.
     *        This can be constructed from Indexer API. If set to null, additional round
     *        trip to Indexer API will be made.
     * @param currentHeight Current block height. This can be obtained from nodeClient.
     *        If set to null, additional round trip to nodeClient will be made.
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    placeOrder(subaccount: WalletSubaccountInfo, marketId: string, type: OrderType, side: OrderSide, price: number, size: number, clientId: number, timeInForce?: OrderTimeInForce, goodTilTimeInSeconds?: number, routerFeePpm?: number, routerSubaccount?: SubaccountInfo, execution?: OrderExecution, postOnly?: boolean, reduceOnly?: boolean, triggerPrice?: number, marketInfo?: MarketInfo, currentHeight?: number, goodTilBlock?: number, memo?: string): TxResponsePromise;
    /**
     * @description Calculate and create the place order message
     *
     * Only MARKET and LIMIT types are supported right now
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param type The type of order to place
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilTimeInSeconds The goodTilTimeInSeconds of the order to place
     * @param routerFeePpm The ppm fee that goes to the exchange that routed the order
     * @param routerSubaccount The subaccount of the exchange that routed the order
     * @param execution The execution of the order to place
     * @param postOnly The postOnly of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message to be passed into the protocol
     */
    private placeOrderMessage;
    private retrieveMarketInfo;
    /**
     * @description Calculate and create the short term place order message
     *
     * Use human readable form of input, including price and size
     * The quantum and subticks are calculated and submitted
     *
     * @param subaccount The subaccount to place the order under
     * @param marketId The market to place the order on
     * @param side The side of the order to place
     * @param price The price of the order to place
     * @param size The size of the order to place
     * @param clientId The client id of the order to place
     * @param timeInForce The time in force of the order to place
     * @param goodTilBlock The goodTilBlock of the order to place
     * @param reduceOnly The reduceOnly of the order to place
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message to be passed into the protocol
     */
    private placeShortTermOrderMessage;
    /**
     * @description Cancel an order with order information from web socket or REST.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param clientId The client id of the order to cancel
     * @param orderFlags The order flags of the order to cancel
     * @param clobPairId The clob pair id of the order to cancel
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    cancelRawOrder(subaccount: WalletSubaccountInfo, clientId: number, orderFlags: OrderFlags, clobPairId: number, goodTilBlock?: number, goodTilBlockTime?: number): TxResponsePromise;
    /**
     * @description Cancel an order with human readable input.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param clientId The client id of the order to cancel
     * @param orderFlags The order flags of the order to cancel
     * @param marketId The market to cancel the order on
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @param goodTilBlockTime The goodTilBlockTime of the order to cancel
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    cancelOrder(subaccount: WalletSubaccountInfo, clientId: number, orderFlags: OrderFlags, ticker: string, goodTilBlock?: number, goodTilTimeInSeconds?: number): TxResponsePromise;
    /**
     * @description Batch cancel short term orders using marketId to clobPairId translation.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param shortTermOrders The list of short term order batches to cancel with marketId
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @returns The transaction hash.
     */
    batchCancelShortTermOrdersWithMarketId(subaccount: WalletSubaccountInfo, shortTermOrders: OrderBatchWithMarketId[], goodTilBlock: number, broadcastMode?: BroadcastMode): TxResponsePromise;
    /**
     * @description Batch cancel short term orders using clobPairId.
     *
     * @param subaccount The subaccount to cancel the order from
     * @param shortTermOrders The list of short term order batches to cancel with clobPairId
     * @param goodTilBlock The goodTilBlock of the order to cancel
     * @returns The transaction hash.
     */
    batchCancelShortTermOrdersWithClobPairId(subaccount: WalletSubaccountInfo, shortTermOrders: OrderBatch[], goodTilBlock: number, broadcastMode?: BroadcastMode): TxResponsePromise;
    /**
     * @description Transfer from a subaccount to another subaccount
     *
     * @param subaccount The subaccount to transfer from
     * @param recipientAddress The recipient address
     * @param recipientSubaccountNumber The recipient subaccount number
     * @param amount The amount to transfer
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    transferToSubaccount(subaccount: WalletSubaccountInfo, recipientAddress: string, recipientSubaccountNumber: number, amount: string, memo?: string, broadcastMode?: BroadcastMode): TxResponsePromise;
    /**
     * @description Create message to transfer from a subaccount to another subaccount
     *
     * @param subaccount The subaccount to transfer from
     * @param recipientAddress The recipient address
     * @param recipientSubaccountNumber The recipient subaccount number
     * @param amount The amount to transfer
     *
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    transferToSubaccountMessage(subaccount: WalletSubaccountInfo, recipientAddress: string, recipientSubaccountNumber: number, amount: string): EncodeObject;
    /**
     * @description Deposit from wallet to subaccount
     *
     * @param subaccount The subaccount to deposit to
     * @param amount The amount to deposit
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash.
     */
    depositToSubaccount(subaccount: WalletSubaccountInfo, amount: string, memo?: string): TxResponsePromise;
    /**
     * @description Create message to deposit from wallet to subaccount
     *
     * @param subaccount The subaccount to deposit to
     * @param amount The amount to deposit
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    depositToSubaccountMessage(subaccount: WalletSubaccountInfo, amount: string): EncodeObject;
    /**
     * @description Withdraw from subaccount to wallet
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address, default to subaccount address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The transaction hash
     */
    withdrawFromSubaccount(subaccount: WalletSubaccountInfo, amount: string, recipient?: string, memo?: string): TxResponsePromise;
    /**
     * @description Create message to withdraw from subaccount to wallet
     * with human readable input.
     *
     * @param subaccount The subaccount to withdraw from
     * @param amount The amount to withdraw
     * @param recipient The recipient address
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The message
     */
    withdrawFromSubaccountMessage(subaccount: WalletSubaccountInfo, amount: string, recipient?: string): EncodeObject;
    signPlaceOrder(subaccount: WalletSubaccountInfo, marketId: string, type: OrderType, side: OrderSide, price: number, size: number, clientId: number, timeInForce: OrderTimeInForce, goodTilTimeInSeconds: number, execution: OrderExecution, postOnly: boolean, reduceOnly: boolean, routerFeePpm?: number, routerSubaccount?: SubaccountInfo): Promise<string>;
    signCancelOrder(subaccount: WalletSubaccountInfo, clientId: number, orderFlags: OrderFlags, clobPairId: number, goodTilBlock: number, goodTilBlockTime: number): Promise<string>;
}
export {};
