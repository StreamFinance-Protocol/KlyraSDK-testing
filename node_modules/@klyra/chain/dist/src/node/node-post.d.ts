import { type EncodeObject } from "@cosmjs/proto-signing";
import { type Account, GasPrice, type StdFee } from "@cosmjs/stargate";
import Long from "long";
import { type SubaccountInfo, type WalletSubaccountInfo } from "../lib/subaccount";
import { OrderFlags, type BroadcastMode, type IPlaceOrder, type ICancelOrder, type TxResponsePromise } from "../types";
import Composer from "../lib/composer";
import { type LocalWallet } from "../lib/local-wallet";
import { type Order_Side, type Order_TimeInForce, Order_ConditionType, type OrderBatch } from "../lib/proto-includes";
import type NodeGet from "./node-get";
export default class NodePost {
    readonly composer: Composer;
    private readonly registry;
    private readonly chainId;
    readonly get: NodeGet;
    readonly defaultClientMemo?: string;
    readonly defaultGasPrice: GasPrice;
    useTimestampNonce: boolean;
    private accountNumberCache;
    constructor(get: NodeGet, chainId: string, defaultClientMemo?: string, useTimestampNonce?: boolean);
    /**
     * @description Retrieves the account number for the given wallet address and populates the accountNumberCache.
     * The account number is required for txOptions when signing a transaction.
     * Pre-populating the cache avoids a round-trip request during the first transaction creation in the session, preventing it from being a performance blocker.
     */
    populateAccountNumberCache(address: string): Promise<void>;
    getGasPrice(): GasPrice;
    /**
     * @description Simulate a transaction
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Fee for broadcasting a transaction.
     */
    simulate(wallet: LocalWallet, messaging: () => Promise<EncodeObject[]>, gasPrice?: GasPrice, memo?: string, account?: () => Promise<Account>): Promise<StdFee>;
    /**
     * @description Sign a transaction
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Signature.
     */
    sign(wallet: LocalWallet, messaging: () => Promise<EncodeObject[]>, zeroFee: boolean, gasPrice?: GasPrice, memo?: string, account?: () => Promise<Account>): Promise<Uint8Array>;
    /**
     * @description Send a transaction
     * the calling function is responsible for creating the messages.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Tx Hash.
     */
    send(wallet: LocalWallet, messaging: () => Promise<EncodeObject[]>, zeroFee: boolean, gasPrice?: GasPrice, memo?: string, broadcastMode?: BroadcastMode, account?: () => Promise<Account>, gasAdjustment?: number): TxResponsePromise;
    /**
     * @description Calculate the default broadcast mode.
     */
    private defaultBroadcastMode;
    /**
     * @description Sign and send a message
     *
     * @returns The Tx Response.
     */
    private signTransaction;
    /**
     * @description Retrieve an account structure for transactions.
     * For short term orders, the sequence doesn't matter. Use cached if available.
     * For long term and conditional orders, a round trip to validator must be made.
     * when timestamp nonce is supported, no need to fetch account sequence number
     */
    account(address: string, orderFlags?: OrderFlags): Promise<Account>;
    /**
     * @description Sign and send a message
     *
     * @returns The Tx Response.
     */
    private signAndSendTransaction;
    /**
     * @description Send signed transaction.
     *
     * @returns The Tx Response.
     */
    sendSignedTransaction(signedTransaction: Uint8Array, broadcastMode?: BroadcastMode): TxResponsePromise;
    /**
     * @description Simulate broadcasting a transaction.
     *
     * @throws UnexpectedClientError if a malformed response is returned with no GRPC error
     * at any point.
     * @returns The Fee for broadcasting a transaction.
     */
    private simulateTransaction;
    placeOrder(subaccount: WalletSubaccountInfo, clientId: number, clobPairId: number, side: Order_Side, quantums: Long, subticks: Long, routerFeePpm: number, routerSubaccount: SubaccountInfo, timeInForce: Order_TimeInForce, orderFlags: number, reduceOnly: boolean, goodTilBlock?: number, goodTilBlockTime?: number, clientMetadata?: number, conditionType?: Order_ConditionType, conditionalOrderTriggerSubticks?: Long, broadcastMode?: BroadcastMode): TxResponsePromise;
    placeOrderMsg(address: string, subaccountNumber: number, clientId: number, clobPairId: number, side: Order_Side, quantums: Long, subticks: Long, routerFeePpm: number, routerSubaccountAddress: string, routerSubaccountNumber: number, timeInForce: Order_TimeInForce, orderFlags: number, reduceOnly: boolean, goodTilBlock?: number, goodTilBlockTime?: number, clientMetadata?: number, conditionType?: Order_ConditionType, conditionalOrderTriggerSubticks?: Long): Promise<EncodeObject>;
    placeOrderObject(subaccount: WalletSubaccountInfo, routerSubaccount: SubaccountInfo, placeOrder: IPlaceOrder, broadcastMode?: BroadcastMode): TxResponsePromise;
    cancelOrder(subaccount: WalletSubaccountInfo, clientId: number, orderFlags: OrderFlags, clobPairId: number, goodTilBlock?: number, goodTilBlockTime?: number, broadcastMode?: BroadcastMode): TxResponsePromise;
    cancelOrderMsg(address: string, subaccountNumber: number, clientId: number, orderFlags: OrderFlags, clobPairId: number, goodTilBlock?: number, goodTilBlockTime?: number): Promise<EncodeObject>;
    cancelOrderObject(subaccount: WalletSubaccountInfo, cancelOrder: ICancelOrder, broadcastMode?: BroadcastMode): TxResponsePromise;
    batchCancelShortTermOrders(subaccount: WalletSubaccountInfo, shortTermOrders: OrderBatch[], goodTilBlock: number, broadcastMode?: BroadcastMode): TxResponsePromise;
    batchCancelShortTermOrdersMsg(address: string, subaccountNumber: number, shortTermOrders: OrderBatch[], goodTilBlock: number): Promise<EncodeObject>;
    transfer(subaccount: WalletSubaccountInfo, recipientAddress: string, recipientSubaccountNumber: number, assetId: number, amount: Long, broadcastMode?: BroadcastMode): TxResponsePromise;
    transferMsg(address: string, subaccountNumber: number, recipientAddress: string, recipientSubaccountNumber: number, assetId: number, amount: Long): Promise<EncodeObject>;
    deposit(subaccount: WalletSubaccountInfo, assetId: number, quantums: Long, broadcastMode?: BroadcastMode): TxResponsePromise;
    depositMsg(address: string, subaccountNumber: number, assetId: number, quantums: Long): Promise<EncodeObject>;
    withdraw(subaccount: WalletSubaccountInfo, assetId: number, quantums: Long, recipient?: string, broadcastMode?: BroadcastMode): TxResponsePromise;
    withdrawMsg(address: string, subaccountNumber: number, assetId: number, quantums: Long, recipient?: string): Promise<EncodeObject>;
    sendNativeToken(subaccount: WalletSubaccountInfo, recipient: string, coinDenom: string, quantums: string, zeroFee?: boolean, broadcastMode?: BroadcastMode): TxResponsePromise;
    sendNativeTokenMsg(address: string, recipient: string, coinDenom: string, quantums: string): Promise<EncodeObject>;
}
